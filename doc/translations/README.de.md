# Tostore

[English](../../README.md) | [ÁÆÄ‰Ωì‰∏≠Êñá](README.zh-CN.md) | [Êó•Êú¨Ë™û](README.ja.md) | [ÌïúÍµ≠Ïñ¥](README.ko.md) | [Espa√±ol](README.es.md) | [Portugu√™s (Brasil)](README.pt-BR.md) | [–†—É—Å—Å–∫–∏–π](README.ru.md) | Deutsch | [Fran√ßais](README.fr.md) | [Italiano](README.it.md) | [T√ºrk√ße](README.tr.md)

[![pub package](https://img.shields.io/pub/v/tostore.svg)](https://pub.dev/packages/tostore)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Platform](https://img.shields.io/badge/Platform-Flutter-02569B?logo=flutter)](https://flutter.dev)
[![Dart Version](https://img.shields.io/badge/Dart-3.5+-00B4AB.svg?logo=dart)](https://dart.dev)


## Warum Tostore w√§hlen?

Tostore ist die einzige Hochleistungs-Speicher-Engine f√ºr verteilte Vektordatenbanken im Dart/Flutter-√ñkosystem. Basierend auf einer neuronalen netzwerk√§hnlichen Architektur bietet es eine intelligente Vernetzung und Zusammenarbeit zwischen den Knoten und unterst√ºtzt eine unendliche horizontale Skalierung. Es baut ein flexibles Datentopologie-Netzwerk auf und bietet pr√§zise Identifizierung von Schema√§nderungen, Verschl√ºsselungsschutz sowie Multi-Space-Datentrennung. Tostore nutzt Multi-Core-CPUs f√ºr extrem parallele Verarbeitung voll aus und unterst√ºtzt nativ die plattform√ºbergreifende Zusammenarbeit von mobilen Edge-Ger√§ten bis hin zur Cloud. Mit verschiedenen verteilten Prim√§rschl√ºssel-Algorithmen bietet es eine leistungsstarke Datengrundlage f√ºr Szenarien wie immersive Virtual Reality, multimodale Interaktion, Spatial Computing, generative KI und semantische Vektorraumodellierung.

Da generative KI und Spatial Computing das Rechenzentrum an den Rand (Edge) verschieben, entwickeln sich Endger√§te von reinen Inhaltsanzeigen zu Kernpunkten f√ºr lokale Generierung, Umgebungswahrnehmung und Echtzeit-Entscheidungsfindung. Traditionelle eingebettete Datenbanken mit nur einer Datei sind durch ihr Architekturdesign begrenzt und haben oft Schwierigkeiten, die unmittelbaren Reaktionsanforderungen intelligenter Anwendungen bei hohen parallelen Schreibvorg√§ngen, massiver Vektorsuche und Cloud-Edge-kollaborativer Generierung zu unterst√ºtzen. Tostore wurde f√ºr Edge-Ger√§te entwickelt und verleiht ihnen verteilte Speicherf√§higkeiten, die ausreichen, um komplexe lokale KI-Generierung und gro√üfl√§chigen Datenfluss zu unterst√ºtzen ‚Äì eine echte tiefe Zusammenarbeit zwischen Cloud und Edge.

**Stromausfall- und absturzsicher**: Selbst bei einem unerwarteten Stromausfall oder Anwendungsabsturz k√∂nnen Daten automatisch wiederhergestellt werden, was einen echten Null-Verlust bedeutet. Sobald eine Datenoperation best√§tigt wird, wurden die Daten bereits sicher gespeichert, sodass kein Risiko eines Datenverlusts besteht.

**Leistungsgrenzen sprengen**: Tests zeigen, dass selbst bei √ºber 100 Millionen Datens√§tzen ein typisches Smartphone eine konstante Suchleistung unabh√§ngig vom Datenvolumen beibeh√§lt und ein Erlebnis bietet, das herk√∂mmliche Datenbanken bei weitem √ºbertrifft.




...... Von den Fingerspitzen bis zu Cloud-Anwendungen hilft Tostore Ihnen, die Datenrechenleistung freizusetzen und die Zukunft zu gestalten ......




## Tostore-Funktionen

- üåê **Nahtlose Unterst√ºtzung aller Plattformen**
  - F√ºhren Sie denselben Code auf allen Plattformen aus, von mobilen Apps bis hin zu Cloud-Servern.
  - Passt sich intelligent an verschiedene Plattform-Speicher-Backends an (IndexedDB, Dateisystem usw.).
  - Einheitliche API-Schnittstelle f√ºr sorgenfreie plattform√ºbergreifende Datensynchronisation.
  - Nahtloser Datenfluss von Edge-Ger√§ten zu Cloud-Servern.
  - Lokale Vektorberechnung auf Edge-Ger√§ten, wodurch Netzwerklatenz und Cloud-Abh√§ngigkeit reduziert werden.

- üß† **Neuronale netzwerk√§hnliche verteilte Architektur**
  - Vernetzte Knotentopologie f√ºr eine effiziente Organisation des Datenflusses.
  - Hochleistungs-Datenpartitionierungsmechanismus f√ºr echte verteilte Verarbeitung.
  - Intelligenter dynamischer Workload-Ausgleich zur Maximierung der Ressourcennutzung.
  - Unendliche horizontale Skalierung von Knoten zum einfachen Aufbau komplexer Datennetzwerke.

- ‚ö° **Extreme parallele Verarbeitungsf√§higkeit**
  - Echtes paralleles Lesen/Schreiben mit Isolates, mit voller Geschwindigkeit auf Multi-Core-CPUs.
  - Intelligente Ressourcenplanung gleicht die Last automatisch aus, um die Multi-Core-Leistung zu maximieren.
  - Kollaboratives Multi-Knoten-Rechennetzwerk verdoppelt die Effizienz der Aufgabenverarbeitung.
  - Ressourcenbewusstes Planungs-Framework optimiert automatisch Ausf√ºhrungspl√§ne, um Ressourcenkonflikte zu vermeiden.
  - Streaming-Abfrageschnittstelle verarbeitet massive Datens√§tze m√ºhelos.

- üîë **Vielf√§ltige verteilte Prim√§rschl√ºssel-Algorithmen**
  - Sequenzieller Inkrement-Algorithmus - Passen Sie die zuf√§lligen Schrittweiten frei an, um das Gesch√§ftsvolumen zu verbergen.
  - Zeitstempel-basierter Algorithmus - Die beste Wahl f√ºr Szenarien mit hoher Parallelit√§t.
  - Datums-Pr√§fix-Algorithmus - Perfekte Unterst√ºtzung f√ºr die Anzeige von Daten in Zeitr√§umen.
  - Kurzcode-Algorithmus - Erzeugt kurze, gut lesbare eindeutige Identifikatoren.

- üîÑ **Intelligente Schema-Migration & Datenintegrit√§t**
  - Identifiziert pr√§zise umbenannte Tabellenfelder ohne Datenverlust.
  - Automatische Erkennung von Schema√§nderungen und Datenmigration in Millisekunden.
  - Upgrades ohne Ausfallzeiten, nahtlos f√ºr den Betrieb.
  - Sichere Migrationsstrategien f√ºr komplexe Struktur√§nderungen.
  - Automatische Fremdschl√ºssel-Validierung mit Kaskadierung zur Sicherstellung der referenziellen Integrit√§t.

- üõ°Ô∏è **Sicherheit & Langlebigkeit auf Unternehmensebene**
  - Doppeltes Schutzmechanismus: Echtzeit-Protokollierung von Daten√§nderungen stellt sicher, dass nichts verloren geht.
  - Automatische Wiederherstellung nach Absturz: Setzt unvollst√§ndige Operationen nach Stromausfall oder Absturz automatisch fort.
  - Datenkonsistenzgarantie: Operationen sind entweder vollst√§ndig erfolgreich oder werden komplett zur√ºckgesetzt (Rollback).
  - Atomare Berechnungs-Updates: Das Ausdruckssystem unterst√ºtzt komplexe Berechnungen, die atomar ausgef√ºhrt werden, um Parallelit√§tskonflikte zu vermeiden.
  - Sofortige sichere Speicherung: Daten sind sicher gespeichert, sobald die Operation erfolgreich war.
  - Hochfeste ChaCha20Poly1305-Verschl√ºsselung sch√ºtzt sensible Daten.
  - Ende-zu-Ende-Verschl√ºsselung f√ºr Sicherheit bei Speicherung und √úbertragung.

- üöÄ **Intelligentes Caching & Abfrageleistung**
  - Mehrstufiger intelligenter Caching-Mechanismus f√ºr blitzschnelle Datenabfragen.
  - Caching-Strategien, die tief in die Speicher-Engine integriert sind.
  - Adaptive Skalierung beh√§lt die stabile Leistung bei wachsendem Datenvolumen bei.
  - Echtzeit-Benachrichtigungen √ºber Daten√§nderungen mit automatischer Aktualisierung der Abfrageergebnisse.

- üîÑ **Intelligenter Datenworkflow**
  - Multi-Space-Architektur bietet Datentrennung bei gleichzeitiger globaler Teilung.
  - Intelligente Workload-Verteilung √ºber Rechenknoten hinweg.
  - Bietet eine solide Grundlage f√ºr gro√ü angelegtes Datentraining und Analysen.


## Installation

> [!IMPORTANT]
> **Upgrade von v2.x?** Bitte lesen Sie den [v3.0 Upgrade-Leitfaden](../UPGRADE_GUIDE_v3.md) f√ºr wichtige Migrationsschritte und bahnbrechende √Ñnderungen.

F√ºgen Sie `tostore` als Abh√§ngigkeit in Ihre `pubspec.yaml` ein:

```yaml
dependencies:
  tostore: any # Bitte verwenden Sie die neueste Version
```

## Schnellstart

> [!IMPORTANT]
> **Die Definition des Tabellenschemas ist der erste Schritt**: Bevor Sie CRUD-Operationen durchf√ºhren, m√ºssen Sie das Tabellenschema definieren. Die spezifische Definition Methode h√§ngt von Ihrem Szenario ab:
> - **Mobil/Desktop**: Empfohlen [Statische Definition](#integration-f√ºr-szenarien-mit-h√§ufigem-start).
> - **Serverseitig**: Empfohlen [Dynamische Erstellung](#serverseitige-integration).

```dart
// 1. Datenbank initialisieren
final db = await ToStore.open();

// 2. Daten einf√ºgen
await db.insert('users', {
  'username': 'John',
  'email': 'john@example.com',
  'age': 25,
});

// 3. Verkettete Abfragen ([Abfrageoperatoren](#abfrageoperatoren), unterst√ºtzt =, !=, >, <, LIKE, IN usw.)
final users = await db.query('users')
    .where('age', '>', 20)
    .where('username', 'like', '%John%')
    .orderByDesc('age')
    .limit(20);

// 4. Aktualisieren und L√∂schen
await db.update('users', {'age': 26}).where('username', '=', 'John');
await db.delete('users').where('username', '=', 'John');

// 5. Echtzeit-√úberwachung (UI aktualisiert sich automatisch bei Daten√§nderungen)
db.query('users').where('age', '>', 18).watch().listen((users) {
  print('Passende Benutzer aktualisiert: $users');
});
```

### Key-Value-Speicher (KV)
Geeignet f√ºr Szenarien, die es nicht erfordern, strukturierte Tabellen zu definieren. Es ist einfach, praktisch und enth√§lt einen integrierten Hochleistungs-KV-Speicher f√ºr Konfigurationen, Status und andere verstreute Daten. Daten in verschiedenen Spaces sind von Natur aus isoliert, k√∂nnen aber f√ºr die globale Freigabe konfiguriert werden.

```dart
// 1. Key-Value-Paare setzen (Unterst√ºtzt String, int, bool, double, Map, List usw.)
await db.setValue('theme', 'dark');
await db.setValue('login_attempts', 3);

// 2. Daten abrufen
final theme = await db.getValue('theme'); // 'dark'

// 3. Daten l√∂schen
await db.removeValue('theme');

// 4. Globaler Key-Value (Space-√ºbergreifend geteilt)
// Standardm√§√üig sind KV-Daten Space-spezifisch. Verwenden Sie isGlobal: true f√ºr globale Freigabe.
await db.setValue('app_version', '1.0.0', isGlobal: true);
final version = await db.getValue('app_version', isGlobal: true);
```



## Integration f√ºr Szenarien mit h√§ufigem Start

üì± **Beispiel**: [mobile_quickstart.dart](example/lib/mobile_quickstart.dart)

```dart
// Schemadefinition geeignet f√ºr mobile/Desktop-Apps mit h√§ufigen Starts.
// Erkennt Schema√§nderungen pr√§zise und migriert Daten automatisch ohne Code-Wartung.
final db = await ToStore.open(
  schemas: [
    const TableSchema(
            name: 'global_settings',
            isGlobal: true,  // Globale Tabelle, f√ºr alle Spaces zug√§nglich
            fields: [],
    ),
    const TableSchema(
      name: 'users', // Tabellenname
      tableId: "users",  // Eindeutige ID f√ºr 100%ige Erkennung von Umbenennungen
      primaryKeyConfig: PrimaryKeyConfig(
        name: 'id',       // Prim√§rschl√ºssel-Name
      ),
      fields: [        // Felddefinitionen (ohne Prim√§rschl√ºssel)
        FieldSchema(
          name: 'username', 
          type: DataType.text, 
          nullable: false, 
          unique: true, // Erstellt automatisch einen eindeutigen Index
          fieldId: 'username',  // Eindeutige Feld-ID
        ),
        FieldSchema(
          name: 'email', 
          type: DataType.text, 
          nullable: false, 
          unique: true // Erstellt automatisch einen eindeutigen Index
        ),
        FieldSchema(
          name: 'last_login', 
          type: DataType.datetime,
          createIndex: true // Erstellt automatisch einen Index (idx_last_login)
        ),
      ],
      // Beispiel f√ºr zusammengesetzten Index
      indexes: [
        IndexSchema(fields: ['username', 'last_login']),
      ],
    ),
    // Beispiel f√ºr Fremdschl√ºssel-Einschr√§nkung
    TableSchema(
      name: 'posts',
      primaryKeyConfig: const PrimaryKeyConfig(name: 'id'),
      fields: [
        const FieldSchema(name: 'title', type: DataType.text, nullable: false),
        const FieldSchema(name: 'user_id', type: DataType.integer, nullable: false),
        const FieldSchema(name: 'content', type: DataType.text),
      ],
      foreignKeys: [
        ForeignKeySchema(
          name: 'fk_posts_user',
          fields: ['user_id'],              // Aktuelle Tabellenfelder
          referencedTable: 'users',         // Referenzierte Tabelle
          referencedFields: ['id'],         // Referenzierte Felder
          onDelete: ForeignKeyCascadeAction.cascade,  // Kaskadierendes L√∂schen
          onUpdate: ForeignKeyCascadeAction.cascade,  // Kaskadierendes Aktualisieren
        ),
      ],
    ),
  ],
);

// Multi-Space-Architektur - perfekte Trennung von Daten verschiedener Benutzer
await db.switchSpace(spaceName: 'user_123');
```

### Login-Zustand beibehalten und Abmelden (aktiver Space)

Multi-Space eignet sich f√ºr **Daten pro Benutzer**: ein Space pro Benutzer und Wechsel beim Login. Mit **aktivem Space** und der **close**-Option bleibt der aktuelle Benutzer √ºber Neustarts erhalten und Abmelden wird unterst√ºtzt.

- **Login-Zustand beibehalten**: Wenn der Benutzer in seinen Space wechselt, diesen als aktiven Space speichern, damit der n√§chste Start mit default direkt in diesen Space √∂ffnet (kein ‚Äûerst default √∂ffnen, dann wechseln‚Äú n√∂tig).
- **Abmelden**: Beim Abmelden die Datenbank mit `keepActiveSpace: false` schlie√üen, damit beim n√§chsten √ñffnen nicht automatisch der Space des vorherigen Benutzers ge√∂ffnet wird.

```dart

// Nach dem Login: in den Space dieses Benutzers wechseln und f√ºr den n√§chsten Start merken (Login beibehalten)
await db.switchSpace(spaceName: 'user_$userId', keepActive: true);

// Optional: strikt nur mit default √∂ffnen (z. B. nur Login-Bildschirm) ‚Äî gespeicherten aktiven Space nicht verwenden
// final db = await ToStore.open(..., applyActiveSpaceOnDefault: false);

// Beim Abmelden: schlie√üen und aktiven Space l√∂schen, damit der n√§chste Start default verwendet
await db.close(keepActiveSpace: false);
```

## Serverseitige Integration

üñ•Ô∏è **Beispiel**: [server_quickstart.dart](example/lib/server_quickstart.dart)

```dart
final db = await ToStore.open();

// Massenweise Schemaerstellung zur Laufzeit - geeignet f√ºr kontinuierlichen Betrieb
await db.createTables([
  // Speicher f√ºr 3D-r√§umliche Merkmalsvektoren
  const TableSchema(
    name: 'spatial_embeddings',
    primaryKeyConfig: PrimaryKeyConfig(
      name: 'id',
      type: PrimaryKeyType.timestampBased,   // Zeitstempel-PK f√ºr hohe Parallelit√§t
    ),
    fields: [
      FieldSchema(
        name: 'video_name',
        type: DataType.text,
        nullable: false,
      ),
      FieldSchema(
        name: 'spatial_features',
        type: DataType.vector,                // Vektorspeichertyp
        vectorConfig: VectorFieldConfig(
          dimensions: 1024,                   // Hochdimensionaler Vektor
          precision: VectorPrecision.float32, 
        ),
      ),
    ],
    indexes: [
      IndexSchema(
        fields: ['video_name'],
        unique: true,
      ),
      IndexSchema(
        type: IndexType.vector,              // Vektorindex
        fields: ['spatial_features'],
        vectorConfig: VectorIndexConfig(
          indexType: VectorIndexType.hnsw,   // HNSW-Algorithmus f√ºr effiziente ANN
          distanceMetric: VectorDistanceMetric.cosine,
          parameters: {
            'M': 16,
            'efConstruction': 200,
          },
        ),
      ),
    ],
  ),
  // Weitere Tabellen...
]);

// Online-Schema-Updates - Nahtlos f√ºr den Betrieb
final taskId = await db.updateSchema('users')
  .renameTable('users_new')                // Tabelle umbenennen
  .modifyField(
    'username',
    minLength: 5,
    maxLength: 20,
    unique: true
  )                                        // Feldattribute √§ndern
  .renameField('old_name', 'new_name')     // Feld umbenennen
  .removeField('deprecated_field')         // Feld entfernen
  .addField('created_at', type: DataType.datetime)  // Feld hinzuf√ºgen
  .removeIndex(fields: ['age'])            // Index entfernen
  .setPrimaryKeyConfig(                    // PK-Konfiguration √§ndern
    const PrimaryKeyConfig(type: PrimaryKeyType.shortCode)
  );
    
// Migrationsfortschritt √ºberwachen
final status = await db.queryMigrationTaskStatus(taskId);
print('Migrationsfortschritt: ${status?.progressPercentage}%');


// Manuelle Abfrage-Cache-Verwaltung (Serverseite)
// F√ºr Abfragen auf Prim√§rschl√ºsseln oder indizierten Feldern (Gleichheit, IN-Abfragen) ist die Leistung bereits extrem hoch und eine manuelle Cache-Verwaltung in der Regel unn√∂tig.

// Ein Abfrageergebnis manuell f√ºr 5 Minuten zwischenspeichern.
final activeUsers = await db.query('users')
    .where('is_active', '=', true)
    .useQueryCache(const Duration(minutes: 5));

// Bestimmten Cache bei Daten√§nderungen ung√ºltig machen, um Konsistenz zu gew√§hrleisten.
await db.query('users')
    .where('is_active', '=', true)
    .clearQueryCache();

// Cache explizit deaktivieren f√ºr Abfragen, die Echtzeitdaten erfordern.
final freshUserData = await db.query('users')
    .where('is_active', '=', true)
    .noQueryCache();
```



## Fortgeschrittene Nutzung

Tostore bietet eine Vielzahl fortgeschrittener Funktionen f√ºr komplexe Gesch√§ftsanforderungen:

### Verschachtelte Abfragen & Benutzerdefinierte Filterung
Unterst√ºtzt unendliche Verschachtelung von Bedingungen und flexible benutzerdefinierte Funktionen.

```dart
// Verschachtelung von Bedingungen: (type = 'app' OR (id >= 123 OR fans >= 200))
final idCondition = QueryCondition().where('id', '>=', 123).or().where('fans', '>=', 200);

final result = await db.query('users')
    .condition(
        QueryCondition().whereEqual('type', 'app').or().condition(idCondition)
    )
    .limit(20);

// Benutzerdefinierte Bedingungsfunktion
final customResult = await db.query('users')
    .whereCustom((record) => record['tags']?.contains('empfohlen') ?? false);
```

### Intelligentes Upsert
Aktualisieren, falls vorhanden, andernfalls einf√ºgen.

```dart
// By primary key or unique key in data (no where)
final result = await db.upsert('users', {'id': 1, 'username': 'john', 'email': 'john@example.com'});
await db.upsert('users', {'username': 'john', 'email': 'john@example.com', 'age': 26});
// Batch upsert
await db.batchUpsert('users', [
  {'username': 'a', 'email': 'a@example.com'},
  {'username': 'b', 'email': 'b@example.com'},
], allowPartialErrors: true);
```


### Joins & Feldauswahl
```dart
final orders = await db.query('orders')
    .select(['orders.id', 'users.name as user_name'])
    .join('users', 'orders.user_id', '=', 'users.id')
    .where('orders.amount', '>', 1000)
    .limit(20);
```

### Streaming & Statistiken
```dart
// Datens√§tze z√§hlen
final count = await db.query('users').count();

// Streaming-Abfrage (geeignet f√ºr massive Daten)
db.streamQuery('users').listen((data) => print(data));
```



### Abfragen & Effiziente Paginierung

> [!TIP]
> **Explizites `limit` f√ºr beste Performance**: Es wird dringend empfohlen, bei Abfragen immer ein `limit` anzugeben. Wenn es weggelassen wird, begrenzt die Engine standardm√§√üig auf 1000 Datens√§tze. Obwohl der Kern der Abfrage extrem schnell ist, kann die Serialisierung einer gro√üen Anzahl von Datens√§tzen in UI-sensitiven Anwendungen zu unn√∂tigen Zeitverz√∂gerungen f√ºhren.

Tostore bietet Unterst√ºtzung f√ºr Dual-Mode-Paginierung passend zu verschiedenen Datenskalen:

#### 1. Offset-Modus
Geeignet f√ºr kleine Datens√§tze (z.B. unter 10k Datens√§tzen) oder wenn spezifische Seitenspr√ºnge erforderlich sind.

```dart
final result = await db.query('users')
    .orderByDesc('created_at')
    .offset(40) // √úberspringe die ersten 40
    .limit(20); // Nimm 20
```
> [!TIP]
> Wenn `offset` sehr gro√ü ist, muss die Datenbank viele Datens√§tze scannen und verwerfen, was zu Leistungseinbu√üen f√ºhrt. Verwenden Sie den **Cursor-Modus** f√ºr Paginierung in der Tiefe.

#### 2. Hochleistungs-Cursor-Modus
**Empfolen f√ºr massive Daten und unendliches Scrollen**. Nutzt `nextCursor` f√ºr O(1)-Leistung und gew√§hrleistet eine konstante Abfragegeschwindigkeit unabh√§ngig von der Seitentiefe.

> [!IMPORTANT]
> Bei Sortierung nach einem nicht indizierten Feld oder bei bestimmten komplexen Abfragen f√§llt die Engine auf einen vollst√§ndigen Tabellenscan zur√ºck und gibt einen `null`-Cursor zur√ºck (was bedeutet, dass die Paginierung f√ºr diese spezifische Abfrage noch nicht unterst√ºtzt wird).

```dart
// Seite 1
final page1 = await db.query('users')
    .orderByDesc('id')
    .limit(20);

// N√§chste Seite mit dem Cursor abrufen
if (page1.nextCursor != null) {
  final page2 = await db.query('users')
      .orderByDesc('id')
      .limit(20)
      .cursor(page1.nextCursor); // Direkt zur Position springen
}

// Effizient r√ºckw√§rts springen mit prevCursor
final prevPage = await db.query('users')
    .limit(20)
    .cursor(page2.prevCursor);
```

| Funktion | Offset-Modus | Cursor-Modus |
| :--- | :--- | :--- |
| **Abfrageleistung** | Sinkt mit steigender Seitenzahl | **Konstant (O(1))** |
| **Komplexit√§t** | Kleine Daten, Seitenspr√ºnge | **Massive Daten, unendliches Scrollen** |
| **Konsistenz** | √Ñnderungen k√∂nnen zu Spr√ºngen f√ºhren | **Vermeidet Duplikate/Auslassungen bei √Ñnderungen** |



### Abfrageoperatoren

Alle Operatoren (gro√ü-/kleinschreibungsunabh√§ngig) f√ºr `where(field, operator, value)`:

| Operator | Description | Example / Value type |
| :--- | :--- | :--- |
| `=` | Equal | `where('status', '=', 'active')` |
| `!=`, `<>` | Not equal | `where('role', '!=', 'guest')` |
| `>` | Greater than | `where('age', '>', 18)` |
| `>=` | Greater than or equal | `where('score', '>=', 60)` |
| `<` | Less than | `where('price', '<', 100)` |
| `<=` | Less than or equal | `where('quantity', '<=', 10)` |
| `IN` | Value in list | `where('id', 'IN', ['a','b','c'])` ‚Äî value: `List` |
| `NOT IN` | Value not in list | `where('status', 'NOT IN', ['banned'])` ‚Äî value: `List` |
| `BETWEEN` | Between start and end (inclusive) | `where('age', 'BETWEEN', [18, 65])` ‚Äî value: `[start, end]` |
| `LIKE` | Pattern match (`%` any, `_` single char) | `where('name', 'LIKE', '%John%')` ‚Äî value: `String` |
| `NOT LIKE` | Pattern not match | `where('email', 'NOT LIKE', '%@test.com')` ‚Äî value: `String` |
| `IS` | Is null | `where('deleted_at', 'IS', null)` ‚Äî value: `null` |
| `IS NOT` | Is not null | `where('email', 'IS NOT', null)` ‚Äî value: `null` |

### Semantische Abfragemethoden (empfohlen)

Semantische Methoden vermeiden manuelle Operatoreingabe und verbessern die IDE-Unterst√ºtzung.

```dart
// Comparison
db.query('users').whereEqual('username', 'John');
db.query('users').whereNotEqual('role', 'guest');
db.query('users').whereGreaterThan('age', 18);
db.query('users').whereGreaterThanOrEqualTo('score', 60);
db.query('users').whereLessThan('price', 100);
db.query('users').whereLessThanOrEqualTo('quantity', 10);

// Membership & range
db.query('users').whereIn('id', ['id1', 'id2']);
db.query('users').whereNotIn('status', ['banned', 'pending']);
db.query('users').whereBetween('age', 18, 65);

// Null checks
db.query('users').whereNull('deleted_at');
db.query('users').whereNotNull('email');

// Pattern match
db.query('users').whereLike('name', '%John%');
db.query('users').whereNotLike('email', '%@temp.');
db.query('users').whereContains('bio', 'flutter');   // LIKE '%flutter%'
db.query('users').whereNotContains('title', 'draft');

// Equivalent to: .where('age', '>', 18).where('name', 'like', '%John%')
final users = await db.query('users')
    .whereGreaterThan('age', 18)
    .whereLike('username', '%John%')
    .orderByDesc('age')
    .limit(20);
```

## Verteilte Architektur

```dart
// Verteilte Knoten konfigurieren
final db = await ToStore.open(
  config: DataStoreConfig(
    distributedNodeConfig: const DistributedNodeConfig(
      enableDistributed: true,
      clusterId: 1,
      centralServerUrl: 'http://127.0.0.1:8080',
      accessToken: 'b7628a4f9b4d269b98649129'
    )
  )
);

// Hochleistungs-Batch-Einf√ºgen
await db.batchInsert('vector_data', [
  {'vector_name': 'face_2365', 'timestamp': DateTime.now()},
  {'vector_name': 'face_2366', 'timestamp': DateTime.now()},
  // ... Datens√§tze effizient in gro√üen Mengen einf√ºgen
]);

// Gro√üe Datens√§tze streamen - Konstanter Speicherverbrauch
await for (final record in db.streamQuery('vector_data')
  .where('vector_name', '=', 'face_2366')
  .where('timestamp', '>=', DateTime.now().subtract(Duration(days: 30)))
  .stream) {
  // Verarbeitet TB-Daten effizient ohne hohen Speicherverbrauch
  print(record);
}
```

## Prim√§rschl√ºssel-Beispiele

Tostore bietet verschiedene verteilte Prim√§rschl√ºssel-Algorithmen:

- **Sequentiell** (PrimaryKeyType.sequential): 238978991
- **Zeitstempel-basiert** (PrimaryKeyType.timestampBased): 1306866018836946
- **Datums-Pr√§fix** (PrimaryKeyType.datePrefixed): 20250530182215887631
- **Kurzcode** (PrimaryKeyType.shortCode): 9eXrF0qeXZ

```dart
// Beispiel f√ºr sequenzielle Prim√§rschl√ºssel-Konfiguration
await db.createTables([
  const TableSchema(
    name: 'users',
    primaryKeyConfig: PrimaryKeyConfig(
      type: PrimaryKeyType.sequential,
      sequentialConfig: SequentialIdConfig(
        initialValue: 10000,
        increment: 50,
        useRandomIncrement: true, // Gesch√§ftsvolumen verbergen
      ),
    ),
    fields: [/* Felddefinitionen */]
  ),
]);
```


## Atomare Ausdrucksoperationen

Das Ausdruckssystem bietet typsichere atomare Feldupdates. Alle Berechnungen werden atomar auf Datenbankebene ausgef√ºhrt, um Parallelit√§tskonflikte zu vermeiden:

```dart
// Einfaches Inkrement: balance = balance + 100
await db.update('accounts', {
  'balance': Expr.field('balance') + Expr.value(100),
}).where('id', '=', accountId);

// Komplexe Berechnung: total = price * quantity + tax
await db.update('orders', {
  'total': Expr.field('price') * Expr.field('quantity') + Expr.field('tax'),
}).where('id', '=', orderId);

// Verschachtelte Klammern: finalPrice = ((price * quantity) + tax) * (1 - discount)
await db.update('orders', {
  'finalPrice': ((Expr.field('price') * Expr.field('quantity')) + Expr.field('tax')) * 
                 (Expr.value(1) - Expr.field('discount')),
}).where('id', '=', orderId);

// Verwendung von Funktionen: price = min(price, maxPrice)
await db.update('products', {
  'price': Expr.min(Expr.field('price'), Expr.field('maxPrice')),
}).where('id', '=', productId);

// Zeitstempel: updatedAt = now()
await db.update('users', {
  'updatedAt': Expr.now(),
}).where('id', '=', userId);
```

## Transaktionen

Transaktionen stellen die Atomarit√§t mehrerer Operationen sicher ‚Äì entweder alle erfolgreich oder alle Rollback, was die Datenkonsistenz garantiert.

**Transaktionsmerkmale**:
- Atomare Ausf√ºhrung mehrerer Operationen.
- Automatische Wiederherstellung unvollst√§ndiger Operationen nach Absturz.
- Daten sind sicher gespeichert nach erfolgreichem Commit.

```dart
// Basis-Transaktion - Atomares Commit mehrerer Operationen
final txResult = await db.transaction(() async {
  // Benutzer einf√ºgen
  await db.insert('users', {
    'username': 'john',
    'email': 'john@example.com',
    'fans': 100,
  });
  
  // Atomares Update mittels Ausdr√ºcken
  await db.update('users', {
    'fans': Expr.field('fans') + Expr.value(50),
  }).where('username', '=', 'john');
  
  // Schl√§gt eine Operation fehl, werden alle √Ñnderungen automatisch zur√ºckgesetzt.
});

if (txResult.isSuccess) {
  print('Transaktion erfolgreich abgeschlossen');
} else {
  print('Transaktion zur√ºckgesetzt: ${txResult.error?.message}');
}

// Automatischer Rollback bei Fehler
final txResult2 = await db.transaction(() async {
  await db.insert('users', {
    'username': 'jane',
    'email': 'jane@example.com',
  });
  throw Exception('Gesch√§ftslogikfehler'); // L√∂st Rollback aus
}, rollbackOnError: true);
```

## Sicherheitskonfiguration

**Datensicherheitsmechanismen**:
- Doppelte Schutzmechanismen stellen sicher, dass Daten nie verloren gehen.
- Automatische Crash-Wiederherstellung f√ºr unvollst√§ndige Operationen.
- Sofortige sichere Persistenz bei Erfolg der Operation.
- Hochfeste Verschl√ºsselung sch√ºtzt sensible Daten.

> [!WARNING]
> **Schl√ºsselverwaltung**: **`encodingKey`** kann frei ge√§ndert werden; der Motor migriert die Daten bei √Ñnderung automatisch, Datenverlust ist nicht zu bef√ºrchten. **`encryptionKey`** darf nicht beliebig ge√§ndert werden‚Äîeine √Ñnderung macht alte Daten unlesbar (au√üer bei Durchf√ºhrung einer Migration). Codieren Sie keine sensiblen Schl√ºssel fest ein; beziehen Sie diese von einem sicheren Server.

```dart
final db = await ToStore.open(
  config: DataStoreConfig(
    encryptionConfig: EncryptionConfig(
      // Unterst√ºtzte Algorithmen: none, xorObfuscation, chacha20Poly1305, aes256Gcm
      encryptionType: EncryptionType.chacha20Poly1305, 
      
      // Kodierungsschl√ºssel (kann frei ge√§ndert werden; Daten werden automatisch migriert)
      encodingKey: 'Ihr-32-Byte-langer-Kodierungsschl√ºssel...', 
      
      // Verschl√ºsselungsschl√ºssel f√ºr kritische Daten (nicht beliebig √§ndern; alte Daten unlesbar ohne Migration)
      encryptionKey: 'Ihr-sicherer-Verschl√ºsselungsschl√ºssel...',
      
      // Ger√§tebindung (Pfad-basiert)
      // Falls aktiviert, werden Schl√ºssel an Pfad und Ger√§temerkmale gebunden.
      // Erh√∂ht Sicherheit gegen Kopieren der Datenbankdateien, aber die 
      // Datenwiederherstellung h√§ngt vom Installationspfad ab.
      deviceBinding: false, 
    ),
    // Write-Ahead Logging (WAL) standardm√§√üig aktiviert
    enableJournal: true, 
    // Erzwungenes Speichern auf Disk beim Commit (f√ºr Leistung auf false setzen)
    persistRecoveryOnCommit: true,
  ),
);
```

### Wert-Level-Verschl√ºsselung (ToCrypto)

Die oben beschriebene Voll-Datenbank-Verschl√ºsselung verschl√ºsselt alle Tabellen- und Indexdaten und kann die Gesamtleistung beeintr√§chtigen. Um nur sensible Felder zu verschl√ºsseln, verwenden Sie **ToCrypto**: Es ist unabh√§ngig von der Datenbank (keine db-Instanz n√∂tig). Sie kodieren bzw. dekodieren Werte selbst vor dem Schreiben oder nach dem Lesen; der Schl√ºssel wird vollst√§ndig von Ihrer App verwaltet. Die Ausgabe ist Base64 und eignet sich f√ºr JSON- oder TEXT-Spalten.

- **key** (erforderlich): `String` oder `Uint8List`. Bei nicht 32 Bytes wird ein 32-Byte-Schl√ºssel per SHA-256 abgeleitet.
- **type** (optional): Verschl√ºsselungstyp [ToCryptoType]: [ToCryptoType.chacha20Poly1305] oder [ToCryptoType.aes256Gcm]. Standard [ToCryptoType.chacha20Poly1305]. Weglassen f√ºr Standard.
- **aad** (optional): Zus√§tzliche authentifizierte Daten ‚Äî `Uint8List`. Wenn beim Kodieren √ºbergeben, m√ºssen beim Dekodieren dieselben Bytes √ºbergeben werden (z. B. Tabellenname + Feldname zur Kontextbindung). Bei einfacher Nutzung weglassen.

```dart
const key = 'my-secret-key';
// Kodieren: Klartext ‚Üí Base64-Chiffre (in DB oder JSON speichern)
final cipher = ToCrypto.encode('sensitive data', key: key);
// Beim Lesen dekodieren
final plain = ToCrypto.decode(cipher, key: key);

// Optional: Kontext mit aad binden (gleiches aad beim Kodieren und Dekodieren)
final aad = Uint8List.fromList(utf8.encode('users:id_number'));
final cipher2 = ToCrypto.encode('secret', key: key, aad: aad);
final plain2 = ToCrypto.decode(cipher2, key: key, aad: aad);
```

## Leistung & Erfahrung

### Leistungsdaten

- **Startgeschwindigkeit**: Sofortiger Start und Datenanzeige selbst bei 100 Mio.+ Datens√§tzen auf durchschnittlichen Smartphones.
- **Abfrageleistung**: Skalenunabh√§ngig, konstant blitzschneller Abruf bei jedem Datenvolumen.
- **Datensicherheit**: ACID-Transaktionsgarantien + Crash-Recovery f√ºr null Datenverlust.

### Empfehlungen

- üì± **Beispielprojekt**: Ein vollst√§ndiges Flutter-App-Beispiel finden Sie im Verzeichnis `example`.
- üöÄ **Produktion**: Verwenden Sie den Release-Modus f√ºr eine Leistung, die den Debug-Modus weit √ºbertrifft.
- ‚úÖ **Standardtests**: Alle Kernfunktionen haben Standard-Integrationstests bestanden.




Falls Tostore Ihnen hilft, geben Sie uns bitte ein ‚≠êÔ∏è




## Roadmap

Tostore entwickelt aktiv Funktionen zur weiteren St√§rkung der Dateninfrastruktur im KI-Zeitalter:

- **Hochdimensionale Vektoren**: Hinzuf√ºgen von Vektorabruf und semantischen Suchalgorithmen.
- **Multimodale Daten**: Bereitstellung von Ende-zu-Ende-Verarbeitung von Rohdaten zu Merkmalsvektoren.
- **Graph-Datenstrukturen**: Unterst√ºtzung f√ºr effiziente Speicherung und Abfrage von Wissensgraphen und komplexen relationalen Netzwerken.





> **Empfehlung**: Mobile Entwickler sollten auch das [Toway Framework](https://github.com/tocreator/toway) in Betracht ziehen, eine Full-Stack-L√∂sung, die Datenabfragen, Laden, Speichern, Caching und Anzeige automatisiert.




## Weitere Ressourcen

- üìñ **Dokumentation**: [Wiki](https://github.com/tocreator/tostore)
- üì¢ **Feedback**: [GitHub Issues](https://github.com/tocreator/tostore/issues)
- üí¨ **Diskussion**: [GitHub Discussions](https://github.com/tocreator/tostore/discussions)


## Lizenz

Dieses Projekt lizenziert unter der MIT-Lizenz ‚Äì siehe die [LICENSE](LICENSE)-Datei f√ºr Details.

---
