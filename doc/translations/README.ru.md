# Tostore

[English](../../README.md) | [简体中文](README.zh-CN.md) | [日本語](README.ja.md) | [한국어](README.ko.md) | [Español](README.es.md) | [Português (Brasil)](README.pt-BR.md) | Русский | [Deutsch](README.de.md) | [Français](README.fr.md) | [Italiano](README.it.md) | [Türkçe](README.tr.md)

[![pub package](https://img.shields.io/pub/v/tostore.svg)](https://pub.dev/packages/tostore)
[![Build Status](https://github.com/tocreator/tostore/workflows/build/badge.svg)](https://github.com/tocreator/tostore/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Platform](https://img.shields.io/badge/Platform-Flutter-02569B?logo=flutter)](https://flutter.dev)
[![Dart Version](https://img.shields.io/badge/Dart-3.5+-00B4AB.svg?logo=dart)](https://dart.dev)

Tostore - это кроссплатформенный движок базы данных с распределенной архитектурой, глубоко интегрированный с вашим проектом. Модель обработки данных, вдохновленная нейронными сетями, реализует управление данными по принципу работы мозга. Механизмы параллелизма множественных разделов и топология взаимосвязанных узлов создают интеллектуальную сеть данных, а параллельная обработка Isolate максимально использует возможности многоядерных процессоров. Благодаря различным алгоритмам распределенных первичных ключей и неограниченному расширению узлов, он может служить слоем данных для инфраструктур распределенных вычислений и обучения данных большого масштаба, обеспечивая бесперебойный поток данных от пограничных устройств до облачных серверов. Такие функции, как точное обнаружение изменений схемы, интеллектуальная миграция, шифрование ChaCha20Poly1305 и архитектура с несколькими пространствами, идеально поддерживают различные сценарии приложений, от мобильных приложений до серверных систем.

## Почему стоит выбрать Tostore?

### 1. Механизм параллельной обработки разделов vs. хранение в одном файле
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Интеллектуальный механизм разделения, данные распределены по нескольким файлам соответствующего размера | ❌ Хранение в одном файле данных, линейное ухудшение производительности с ростом данных |
| ✅ Чтение только соответствующих файлов разделов, производительность запросов не связана с общим объемом данных | ❌ Необходимость загрузки всего файла данных даже для запроса одной записи |
| ✅ Сохранение времени отклика на уровне миллисекунд даже при объемах данных на уровне ТБ | ❌ Значительное увеличение задержки чтения/записи на мобильных устройствах, когда данные превышают 5 МБ |
| ✅ Использование ресурсов пропорционально объему запрашиваемых данных, а не общему объему | ❌ Устройства с ограниченными ресурсами подвержены проблемам с памятью и ошибкам OOM |
| ✅ Технология Isolate позволяет реализовать истинную многоядерную параллельную обработку | ❌ Один файл нельзя обрабатывать параллельно, что приводит к расточительству ресурсов CPU |

### 2. Глубокая интеграция с проектом vs. независимое хранилище данных
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Использование языка Dart, бесшовная интеграция с проектами Flutter/Dart | ❌ Необходимость изучения SQL или специальных языков запросов, увеличение кривой обучения |
| ✅ Один и тот же код поддерживает фронтенд и бэкенд, нет необходимости переключаться между технологическими стеками | ❌ Фронтенд и бэкенд обычно требуют разных баз данных и методов доступа |
| ✅ API цепочки соответствует современным стилям программирования, отличный опыт разработки | ❌ Конкатенация строк SQL уязвима для атак и ошибок, отсутствие типобезопасности |
| ✅ Поддержка реактивного программирования, естественное сочетание с UI-фреймворками | ❌ Требуются дополнительные адаптационные слои для соединения UI и слоя данных |
| ✅ Нет необходимости в сложной конфигурации ORM-отображения, прямое использование объектов Dart | ❌ Сложность объектно-реляционного отображения, высокие затраты на разработку и обслуживание |

### 3. Точное определение изменений структуры таблицы vs. ручное управление миграцией
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Автоматическое распознавание изменений структуры таблицы, нет необходимости в управлении номерами версий | ❌ Зависимость от ручного контроля версий и явного кода миграции |
| ✅ Распознавание изменений таблиц и полей на уровне миллисекунд и автоматическая миграция данных | ❌ Необходимость поддерживать логику миграции для обновления между версиями |
| ✅ Точное распознавание переименования таблиц и полей без потери данных | ❌ Переименование таблиц и полей может привести к потере данных |
| ✅ Атомарные операции миграции, обеспечивающие согласованность данных | ❌ Прерывания миграции могут привести к несогласованности данных |
| ✅ Полностью автоматизированное обновление структуры без ручного вмешательства | ❌ Сложная логика обновления и высокие затраты на обслуживание с увеличением числа версий |

### 4. Многопространственная архитектура vs. единое пространство хранения
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Многопространственная архитектура, идеально изолирующая данные разных пользователей | ❌ Единое пространство хранения, смешанное хранение данных нескольких пользователей |
| ✅ Переключение пространства одной строкой кода, просто и эффективно | ❌ Требуются несколько экземпляров базы данных или сложная логика изоляции |
| ✅ Гибкий механизм изоляции пространств и совместного использования глобальных данных | ❌ Трудно сбалансировать изоляцию и совместное использование пользовательских данных |
| ✅ Простой API для копирования или миграции данных между пространствами | ❌ Сложные операции миграции или копирования данных между арендаторами |
| ✅ Запросы автоматически ограничиваются текущим пространством, без необходимости дополнительной фильтрации | ❌ Запросы для разных пользователей требуют сложной фильтрации |

### 5. Полная поддержка платформ vs. ограничения платформы
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Единый API для всех платформ: Linux, Web, Mobile, Desktop | ❌ Разные платформы требуют разных движков хранения и API |
| ✅ Автоматическая адаптация к различным бэкендам хранения платформ, согласованный опыт разработки | ❌ Кроссплатформенная разработка требует обработки различий между платформами |
| ✅ Определение один раз, использование моделей данных на всех платформах | ❌ Необходимость переработки моделей данных для разных платформ |
| ✅ Оптимизированная кроссплатформенная производительность, поддержание согласованного пользовательского опыта | ❌ Несогласованные характеристики производительности на разных платформах |
| ✅ Единые стандарты безопасности, реализованные на всех платформах | ❌ Специфичные для платформы механизмы и конфигурации безопасности |

### 6. Алгоритмы распределенных первичных ключей vs. традиционные автоинкрементные ID
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Четыре алгоритма распределенных первичных ключей, адаптированных к различным сценариям | ❌ Простые автоинкрементные ID, подверженные конфликтам в кластерных средах |
| ✅ Распределенная генерация ID, поддержка операций с чрезвычайно высокой параллельностью | ❌ Последовательная генерация ID становится узким местом при высокой параллельности |
| ✅ Случайная длина шага и распределенные алгоритмы, предотвращающие раскрытие масштаба бизнеса | ❌ ID раскрывают информацию об объеме бизнеса, создавая угрозы безопасности |
| ✅ От короткого кода до временных меток, удовлетворяют различным требованиям читабельности и производительности | ❌ Ограниченные типы ID и варианты настройки |

### 7. Потоковая обработка данных vs. пакетная загрузка
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Интерфейс потоковых запросов, обработка данных по требованию, низкое использование памяти | ❌ Одновременная загрузка всех результатов, склонность к OOM с большими наборами данных |
| ✅ Поддержка асинхронной итерации и шаблонов реактивного программирования | ❌ Синхронная модель обработки блокирует UI-поток, влияя на пользовательский опыт |
| ✅ Параллельная обработка потоковых данных, максимальное использование многоядерной производительности | ❌ Последовательная обработка больших объемов данных, низкое использование CPU |
| ✅ Поддержка конвейеров данных и операций преобразования | ❌ Необходимость самостоятельной реализации логики обработки данных |
| ✅ Встроенные механизмы регулирования и обработки противодавления | ❌ Отсутствие контроля потока, легкое истощение ресурсов |

### 8. Интеллектуальная стратегия кэширования vs. традиционное кэширование
| Tostore | Традиционные базы данных |
|:---------|:-----------|
| ✅ Многоуровневые интеллектуальные стратегии кэширования, адаптирующиеся к моделям доступа | ❌ Простое LRU-кэширование, отсутствие гибкости |
| ✅ Автоматическая корректировка стратегии кэширования на основе моделей использования | ❌ Фиксированная конфигурация кэша, трудность динамической настройки |
| ✅ Механизм стартового кэша значительно сокращает время холодного запуска | ❌ Отсутствие стартового кэша, медленный холодный старт, необходимость перестройки кэша |
| ✅ Глубокая интеграция движка хранения с кэшем для оптимальной производительности | ❌ Отдельная логика кэширования и хранения, требующая дополнительных механизмов синхронизации |
| ✅ Автоматическое управление синхронизацией и инвалидацией кэша, без дополнительного кода | ❌ Согласованность кэша требует ручного обслуживания, подверженность ошибкам |



## Основные технические особенности

- 🌐 **Бесшовная поддержка всех платформ**:
  - Согласованный опыт на платформах Web, Linux, Windows, Mobile, Mac
  - Единый API-интерфейс, беспроблемная кроссплатформенная синхронизация данных
  - Автоматическая адаптация к различным бэкендам хранения платформ (IndexedDB, файловые системы и т.д.)
  - Бесперебойный поток данных от граничных вычислений до облака

- 🧠 **Распределенная архитектура в стиле нейронной сети**:
  - Топология взаимосвязанных узлов, подобная нейронной сети
  - Эффективный механизм разделения данных для распределенной обработки
  - Интеллектуальное динамическое балансирование рабочей нагрузки
  - Поддержка неограниченного расширения узлов, легкое построение сложных сетей данных

- ⚡ **Предельные возможности параллельной обработки**:
  - Истинно параллельное чтение/запись с Isolate, полное использование многоядерности CPU
  - Сеть вычислительных узлов, работающих совместно, повышенная эффективность многозадачности
  - Ресурсно-осведомленный фреймворк распределенной обработки, автоматическая оптимизация производительности
  - Интерфейс потоковых запросов, оптимизированный для обработки больших наборов данных

- 🔑 **Разнообразные алгоритмы распределенных первичных ключей**:
  - Алгоритм последовательного увеличения - свободно регулируемая случайная длина шага
  - Алгоритм на основе временных меток - идеален для высокопроизводительных сценариев параллельного выполнения
  - Алгоритм префикса даты - подходит для данных с указанием временного диапазона
  - Алгоритм короткого кода - краткие уникальные идентификаторы

- 🔄 **Интеллектуальная миграция схемы**:
  - Точное распознавание операций переименования таблиц и полей
  - Автоматическое обновление и миграция данных при изменении схемы
  - Обновления без простоя, без влияния на бизнес-операции
  - Безопасные стратегии миграции, предотвращающие потерю данных

- 🛡️ **Корпоративный уровень безопасности**:
  - Алгоритм шифрования ChaCha20Poly1305 для защиты конфиденциальных данных
  - Сквозное шифрование, обеспечение безопасности хранимых и передаваемых данных
  - Детальный контроль доступа к данным

- 🚀 **Интеллектуальное кэширование и производительность поиска**:
  - Многоуровневый интеллектуальный механизм кэширования для эффективного поиска данных
  - Стартовый кэш значительно повышает скорость запуска приложений
  - Глубокая интеграция движка хранения с кэшем, без необходимости в дополнительном коде синхронизации
  - Адаптивное масштабирование, сохранение стабильной производительности с ростом данных

- 🔄 **Инновационные рабочие процессы**:
  - Изоляция данных в нескольких пространствах, идеальная поддержка многопользовательских и многоарендных сценариев
  - Интеллектуальное распределение рабочей нагрузки между вычислительными узлами
  - Предоставление прочной основы данных для крупномасштабного обучения и анализа данных
  - Автоматическое хранение данных, интеллектуальные обновления и вставки

- 💼 **Приоритет опыта разработчика**:
  - Подробная двуязычная документация и комментарии к коду (китайский и английский)
  - Богатая отладочная информация и показатели производительности
  - Встроенные возможности проверки данных и восстановления повреждений
  - Нулевая конфигурация, готовность к использованию, быстрый старт

## Быстрый старт

Основное использование:

```dart
// Инициализация базы данных
final db = ToStore();
await db.initialize(); // Можно опустить, обеспечивает завершение инициализации базы данных перед выполнением операций

// Вставка данных
await db.insert('users', {
  'username': 'John',
  'email': 'john@example.com',
});

// Обновление данных
await db.update('users', {
  'age': 31,
}).where('id', '=', 1);

// Удаление данных
await db.delete('users').where('id', '!=', 1);

// Поддержка сложных цепочных запросов
final users = await db.query('users')
    .where('age', '>', 20)
    .where('name', 'like', '%John%')
    .or()
    .whereIn('id', [1, 2, 3])
    .orderByDesc('age')
    .limit(10);

// Автоматическое хранение данных, обновление при наличии, вставка при отсутствии
await db.upsert('users', {'name': 'John','email': 'john@example.com'})
  .where('email', '=', 'john@example.com');
// Или
await db.upsert('users', {
  'id': 1,
  'name': 'John',
  'email': 'john@example.com'
});


// Эффективный подсчет записей
final count = await db.query('users').count();

// Использование потоковых запросов для обработки больших объемов данных
db.streamQuery('users')
  .where('email', 'like', '%@example.com')
  .listen((userData) {
    // Обработка каждой записи по необходимости, избегая нагрузки на память
    print('Обработка пользователя: ${userData['username']}');
  });


// Установка глобальных пар ключ-значение
await db.setValue('isAgreementPrivacy', true, isGlobal: true);

// Получение глобальных данных пар ключ-значение
final isAgreementPrivacy = await db.getValue('isAgreementPrivacy', isGlobal: true);

```

## Пример мобильного приложения

```dart
// Определение структуры таблицы для сценариев с частым запуском, таких как мобильные приложения, точное определение изменений структуры таблицы, автоматическое обновление и миграция данных
final db = ToStore(
  schemas: [
    const TableSchema(
      name: 'users', // Имя таблицы
      tableId: "users",  // Уникальный идентификатор таблицы, опционально, используется для 100% идентификации требований переименования, без него также можно достичь более 98% точности идентификации
      primaryKeyConfig: PrimaryKeyConfig(
        name: 'id', // Первичный ключ
      ),
      fields: [ // Определение полей, не включая первичный ключ
        FieldSchema(name: 'username', type: DataType.text, nullable: false, unique: true),
        FieldSchema(name: 'email', type: DataType.text, nullable: false, unique: true),
        FieldSchema(name: 'last_login', type: DataType.datetime),
      ],
      indexes: [ // Определение индексов
        IndexSchema(fields: ['username']),
        IndexSchema(fields: ['email']),
      ],
    ),
  ],
);

// Переключение на пространство пользователя - изоляция данных
await db.switchSpace(spaceName: 'user_123');

```

## Пример серверного бэкенда

```dart
await db.createTables([
      const TableSchema(
        name: 'users', // Имя таблицы
        primaryKeyConfig: PrimaryKeyConfig(
          name: 'id', // Первичный ключ
          type: PrimaryKeyType.timestampBased,  // Тип первичного ключа
        ),
        fields: [
          // Определение полей, не включая первичный ключ
          FieldSchema(
              name: 'username',
              type: DataType.text,
              nullable: false,
              unique: true),
          FieldSchema(name: 'vector_data', type: DataType.blob),  // Хранение векторных данных
          // Другие поля ...
        ],
        indexes: [
          // Определение индексов
          IndexSchema(fields: ['username']),
          IndexSchema(fields: ['email']),
        ],
      ),
      // Другие таблицы ...
]);


// Обновление структуры таблицы
final taskId = await db.updateSchema('users')
    .renameTable('newTableName')  // Изменение имени таблицы
    .modifyField('username',minLength: 5,maxLength: 20,unique: true)  // Изменение свойств поля
    .renameField('oldName', 'newName')  // Изменение имени поля
    .removeField('fieldName')  // Удаление поля
    .addField('name', type: DataType.text)  // Добавление поля
    .removeIndex(fields: ['age'])  // Удаление индекса
    .setPrimaryKeyConfig(  // Настройка конфигурации первичного ключа
      const PrimaryKeyConfig(type: PrimaryKeyType.shortCode)
    );
    
// Запрос статуса задачи миграции
final status = await db.queryMigrationTaskStatus(taskId);  
print('Прогресс миграции: ${status?.progressPercentage}%');
```


## Распределенная архитектура

```dart
// Настройка распределенных узлов
final db = ToStore(
    config: DataStoreConfig(
        distributedNodeConfig: const DistributedNodeConfig(
            clusterId: 1,  // Настройка принадлежности к кластеру
            centralServerUrl: 'http://127.0.0.1:8080',
            accessToken: 'b7628a4f9b4d269b98649129'))
);

// Пакетная вставка векторных данных
await db.batchInsert('vector', [
  {'vector_name': 'face_2365', 'timestamp': DateTime.now()},
  {'vector_name': 'face_2366', 'timestamp': DateTime.now()},
  // ... Тысячи записей
]);

// Потоковая обработка больших наборов данных для анализа
await for (final record in db.streamQuery('vector')
    .where('vector_name', '=', 'face_2366')
    .where('timestamp', '>=', DateTime.now().subtract(Duration(days: 30)))
    .stream) {
  // Потоковый интерфейс поддерживает крупномасштабное извлечение и преобразование признаков
  print(record);
}
```

## Примеры первичных ключей
Различные алгоритмы первичных ключей, все поддерживают распределенную генерацию, не рекомендуется самостоятельно генерировать первичные ключи, чтобы избежать влияния неупорядоченных первичных ключей на возможности поиска.
Упорядоченный последовательный первичный ключ PrimaryKeyType.sequential : 238978991
Первичный ключ с временной меткой PrimaryKeyType.timestampBased : 1306866018836946
Первичный ключ с префиксом даты PrimaryKeyType.datePrefixed : 20250530182215887631
Короткий кодовый первичный ключ PrimaryKeyType.shortCode : 9eXrF0qeXZ

```dart
// Упорядоченный последовательный первичный ключ PrimaryKeyType.sequential
// При включении распределенной системы центральный сервер распределяет диапазоны, которые узлы генерируют самостоятельно, компактные и легко запоминающиеся, подходят для ID пользователей и привлекательных номеров
await db.createTables([
      const TableSchema(
        name: 'users',
        primaryKeyConfig: PrimaryKeyConfig(
          type: PrimaryKeyType.sequential,  // Тип последовательного первичного ключа
          sequentialConfig:  SequentialIdConfig(
              initialValue: 10000, // Начальное значение автоинкремента
              increment: 50,  // Шаг автоинкремента
              useRandomIncrement: true,  // Использование случайного шага для предотвращения раскрытия объема бизнеса
            ),
        ),
        // Определение полей и индексов ...
        fields: []
      ),
      // Другие таблицы ...
 ]);
```


## Настройки безопасности

```dart
// Переименование таблиц и полей - автоматическое распознавание и сохранение данных
final db = ToStore(
      config: DataStoreConfig(
        enableEncoding: true, // Включение безопасного кодирования для данных таблицы
        encodingKey: 'YouEncodingKey', // Ключ кодирования, может быть произвольно изменен
        encryptionKey: 'YouEncryptionKey', // Ключ шифрования, примечание: изменение этого ключа предотвратит декодирование старых данных
      ),
    );
```

## Тестирование производительности

Tostore 2.0 реализует линейную масштабируемость производительности, фундаментальные изменения в параллельной обработке, механизме разделения и распределенной архитектуре существенно улучшили возможности поиска данных, обеспечивая отклик на уровне миллисекунд даже при масштабном росте данных. Для обработки больших наборов данных интерфейс потоковых запросов может обрабатывать массивные объемы данных без истощения ресурсов памяти.



## Будущие планы
Tostore разрабатывает поддержку высокоразмерных векторов для обработки мультимодальных данных и семантического поиска.


Наша цель не в создании базы данных; Tostore - это лишь компонент, выделенный из фреймворка Toway для вашего рассмотрения. Если вы разрабатываете мобильное приложение, рекомендуем использовать фреймворк Toway с его интегрированной экосистемой, который предоставляет полный стек решений для разработки Flutter-приложений. С Toway вам не нужно напрямую взаимодействовать с базой данных, все операции запроса, загрузки, хранения, кэширования и отображения данных автоматически выполняются фреймворком.
Для получения дополнительной информации о фреймворке Toway посетите [репозиторий Toway](https://github.com/tocreator/toway).

## Документация

Посетите наш [Wiki](https://github.com/tocreator/tostore) для получения подробной документации.

## Поддержка и обратная связь

- Отправка проблем: [GitHub Issues](https://github.com/tocreator/tostore/issues)
- Присоединение к обсуждению: [GitHub Discussions](https://github.com/tocreator/tostore/discussions)
- Вклад в код: [Contributing Guide](CONTRIBUTING.md)

## Лицензия

Этот проект лицензирован под MIT License - см. файл [LICENSE](LICENSE) для деталей.

---

<p align="center">Если Tostore оказался вам полезен, пожалуйста, дайте нам ⭐️</p>
