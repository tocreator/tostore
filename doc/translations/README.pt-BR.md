# Tostore

[English](../../README.md) | [ÁÆÄ‰Ωì‰∏≠Êñá](README.zh-CN.md) | [Êó•Êú¨Ë™û](README.ja.md) | [ÌïúÍµ≠Ïñ¥](README.ko.md) | [Espa√±ol](README.es.md) | Portugu√™s (Brasil) | [–†—É—Å—Å–∫–∏–π](README.ru.md) | [Deutsch](README.de.md) | [Fran√ßais](README.fr.md) | [Italiano](README.it.md) | [T√ºrk√ße](README.tr.md)

[![pub package](https://img.shields.io/pub/v/tostore.svg)](https://pub.dev/packages/tostore)
[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Platform](https://img.shields.io/badge/Platform-Flutter-02569B?logo=flutter)](https://flutter.dev)
[![Dart Version](https://img.shields.io/badge/Dart-3.5+-00B4AB.svg?logo=dart)](https://dart.dev)


## Por que escolher o Tostore?

O Tostore √© o √∫nico mecanismo de armazenamento de alto desempenho para bancos de dados de vetores distribu√≠dos no ecossistema Dart/Flutter. Utilizando uma arquitetura semelhante a uma rede neural, ele apresenta interconectividade inteligente e colabora√ß√£o entre n√≥s, suportando escalonamento horizontal infinito. Ele constr√≥i uma rede de topologia de dados flex√≠vel e fornece identifica√ß√£o precisa de mudan√ßas de esquema, prote√ß√£o por criptografia e isolamento de dados multiespaciais. O Tostore aproveita totalmente as CPUs multi-core para processamento paralelo extremo e oferece suporte nativo √† colabora√ß√£o multiplataforma, desde dispositivos de borda (edge) m√≥veis at√© a nuvem. Com v√°rios algoritmos de chaves prim√°rias distribu√≠das, ele fornece uma base de dados poderosa para cen√°rios como realidade virtual imersiva, intera√ß√£o multimodal, computa√ß√£o espacial, IA generativa e modelagem de espa√ßo vetorial sem√¢ntico.

√Ä medida que a IA generativa e a computa√ß√£o espacial deslocam o centro de gravidade para a borda (edge), os dispositivos terminais est√£o evoluindo de meros visualizadores de conte√∫do para n√∫cleos de gera√ß√£o local, percep√ß√£o ambiental e tomada de decis√£o em tempo real. Os bancos de dados incorporados tradicionais de arquivo √∫nico s√£o limitados pelo seu design arquitet√¥nico, muitas vezes lutando para suportar os requisitos de resposta imediata de aplica√ß√µes inteligentes diante de grava√ß√µes de alta simultaneidade, recupera√ß√£o de vetores massivos e gera√ß√£o colaborativa nuvem-borda. O Tostore nasceu para dispositivos de borda, dotando-os de capacidades de armazenamento distribu√≠do suficientes para suportar a gera√ß√£o local de IA complexa e o fluxo de dados em larga escala, alcan√ßando uma verdadeira colabora√ß√£o profunda entre a nuvem e a borda.

**Resistente a falhas de energia e travamentos**: Mesmo em caso de uma interrup√ß√£o inesperada de energia ou travamento da aplica√ß√£o, os dados podem ser recuperados automaticamente, alcan√ßando uma perda zero real. Quando uma opera√ß√£o de dados responde, os dados j√° foram salvos com seguran√ßa, eliminando o risco de perda de dados.

**Superando os limites de desempenho**: Testes mostram que, mesmo com mais de 100 milh√µes de registros, um smartphone t√≠pico pode manter desempenho de busca constante independente da escala dos dados, oferecendo uma experi√™ncia que supera em muito a dos bancos de dados tradicionais.




...... Da ponta dos dedos √†s aplica√ß√µes em nuvem, o Tostore ajuda voc√™ a liberar o poder de computa√ß√£o de dados e a impulsionar o futuro ......




## Caracter√≠sticas do Tostore

- üåê **Suporte total multiplataforma cont√≠nuo**
  - Execute o mesmo c√≥digo em todas as plataformas, desde aplicativos m√≥veis at√© servidores em nuvem.
  - Adapta-se inteligentemente a diferentes backends de armazenamento de plataforma (IndexedDB, sistema de arquivos, etc.).
  - Interface API unificada para sincroniza√ß√£o de dados multiplataforma sem preocupa√ß√µes.
  - Fluxo de dados cont√≠nuo de dispositivos de borda para servidores em nuvem.
  - Computa√ß√£o vetorial local em dispositivos de borda, reduzindo a lat√™ncia de rede e a depend√™ncia da nuvem.

- üß† **Arquitetura distribu√≠da tipo rede neural**
  - Estrutura de topologia de n√≥s interconectados para uma organiza√ß√£o eficiente do fluxo de dados.
  - Mecanismo de particionamento de dados de alto desempenho para um verdadeiro processamento distribu√≠do.
  - Equil√≠brio din√¢mico inteligente de carga de trabalho para maximizar a utiliza√ß√£o de recursos.
  - Escalonamento horizontal infinito de n√≥s para construir facilmente redes de dados complexas.

- ‚ö° **M√°xima capacidade de processamento paralelo**
  - Leitura/grava√ß√£o paralela real usando Isolates, funcionando em velocidade m√°xima em CPUs multi-core.
  - O agendamento inteligente de recursos equilibra automaticamente a carga para maximizar o desempenho multi-core.
  - A rede de computa√ß√£o multin√≥ colaborativa dobra a efici√™ncia do processamento de tarefas.
  - O framework de agendamento consciente de recursos otimiza automaticamente os planos de execu√ß√£o para evitar conflitos de recursos.
  - A interface de consulta por fluxo (streaming) lida com conjuntos de dados massivos com facilidade.

- üîë **Diversos algoritmos de chaves prim√°rias distribu√≠das**
  - Algoritmo de incremento sequencial - Ajuste livremente os tamanhos de passo aleat√≥rios para ocultar a escala do neg√≥cio.
  - Algoritmo baseado em timestamp - A melhor escolha para cen√°rios de alta simultaneidade.
  - Algoritmo de prefixo de data - Suporte perfeito para exibi√ß√£o de dados em intervalos de tempo.
  - Algoritmo de c√≥digo curto - Gera identificadores √∫nicos curtos e f√°ceis de ler.

- üîÑ **Migra√ß√£o inteligente de esquema e integridade de dados**
  - Identifica com precis√£o campos de tabela renomeados com zero perda de dados.
  - Detec√ß√£o autom√°tica de mudan√ßas de esquema e migra√ß√£o de dados em milissegundos.
  - Atualiza√ß√µes sem tempo de inatividade, impercept√≠veis para o neg√≥cio.
  - Estrat√©gias de migra√ß√£o seguras para mudan√ßas de estrutura complexas.
  - Valida√ß√£o autom√°tica de restri√ß√µes de chaves estrangeiras com suporte a cascata, garantindo a integridade referencial.

- üõ°Ô∏è **Seguran√ßa e durabilidade de n√≠vel empresarial**
  - Mecanismo de dupla prote√ß√£o: o registro em tempo real das altera√ß√µes de dados garante que nada seja perdido.
  - Recupera√ß√£o autom√°tica de travamentos: retoma automaticamente opera√ß√µes inacabadas ap√≥s falha de energia ou travamento.
  - Garantia de consist√™ncia de dados: as opera√ß√µes ou t√™m sucesso total ou s√£o totalmente revertidas (rollback).
  - Atualiza√ß√µes computacionais at√¥micas: o sistema de express√µes suporta c√°lculos complexos, executados atomicamente para evitar conflitos de concorr√™ncia.
  - Persist√™ncia segura instant√¢nea: os dados s√£o salvos com seguran√ßa quando a opera√ß√£o tem sucesso.
  - O algoritmo de criptografia de alta resist√™ncia ChaCha20Poly1305 protege dados sens√≠veis.
  - Criptografia de ponta a ponta para seguran√ßa durante todo o armazenamento e transmiss√£o.

- üöÄ **Cache inteligente e desempenho de recupera√ß√£o**
  - Mecanismo de cache inteligente multin√≠vel para recupera√ß√£o de dados ultrarr√°pida.
  - Estrat√©gias de cache profundamente integradas com o mecanismo de armazenamento.
  - O escalonamento adaptativo mant√©m o desempenho est√°vel √† medida que a escala de dados cresce.
  - Notifica√ß√µes de altera√ß√µes de dados em tempo real com atualiza√ß√µes autom√°ticas dos resultados de consulta.

- üîÑ **Fluxo de trabalho de dados inteligente**
  - A arquitetura multiespacial fornece isolamento de dados junto com o compartilhamento global.
  - Distribui√ß√£o inteligente da carga de trabalho entre n√≥s de computa√ß√£o.
  - Fornece uma base s√≥lida para treinamento e an√°lise de dados em larga escala.


## Instala√ß√£o

> [!IMPORTANT]
> **Atualizando da v2.x?** Leia o [Guia de atualiza√ß√£o v3.0](../UPGRADE_GUIDE_v3.md) para etapas cr√≠ticas de migra√ß√£o e altera√ß√µes significativas.

Adicione `tostore` como depend√™ncia em seu `pubspec.yaml`:

```yaml
dependencies:
  tostore: any # Por favor, use a vers√£o mais recente
```

## In√≠cio R√°pido

> [!IMPORTANT]
> **Definir o esquema da tabela √© o primeiro passo**: Antes de realizar opera√ß√µes CRUD, voc√™ deve definir o esquema da tabela. O m√©todo de defini√ß√£o espec√≠fico depende do seu cen√°rio:
> - **M√≥vel/Desktop**: Recomendado [Defini√ß√£o est√°tica](#integra√ß√£o-para-cen√°rios-de-inicializa√ß√£o-frequente).
> - **Lado do servidor**: Recomendado [Cria√ß√£o din√¢mica](#integra√ß√£o-no-lado-do-servidor).

```dart
// 1. Inicializar o banco de dados
final db = await ToStore.open();

// 2. Inserir dados
await db.insert('users', {
  'username': 'John',
  'email': 'john@example.com',
  'age': 25,
});

// 3. Consultas encadeadas ([operadores de consulta](#operadores-de-consulta), suporta =, !=, >, <, LIKE, IN, etc.)
final users = await db.query('users')
    .where('age', '>', 20)
    .where('username', 'like', '%John%')
    .orderByDesc('age')
    .limit(10);

// 4. Atualizar e Excluir
await db.update('users', {'age': 26}).where('username', '=', 'John');
await db.delete('users').where('username', '=', 'John');

// 5. Escuta em tempo real (a interface se atualiza automaticamente)
db.query('users').where('age', '>', 18).watch().listen((users) {
  print('Usu√°rios correspondentes atualizados: $users');
});
```

### Armazenamento Chave-Valor (KV)
Adequado para cen√°rios que n√£o exigem definir tabelas estruturadas. √â simples, pr√°tico e inclui um armazenamento KV de alto desempenho integrado para configura√ß√µes, estados e outros datos dispersos. Os dados em espa√ßos (Spaces) diferentes s√£o naturalmente isolados, mas podem ser configurados para compartilhamento global.

```dart
// 1. Definir pares chave-valor (Suporta String, int, bool, double, Map, List, etc.)
await db.setValue('theme', 'dark');
await db.setValue('login_attempts', 3);

// 2. Obter dados
final theme = await db.getValue('theme'); // 'dark'

// 3. Excluir dados
await db.removeValue('theme');

// 4. Chave-valor global (compartilhado entre Spaces)
// Dados KV por padr√£o s√£o espec√≠ficos do espa√ßo. Use isGlobal: true para compartilhamento.
await db.setValue('app_version', '1.0.0', isGlobal: true);
final version = await db.getValue('app_version', isGlobal: true);
```



## Integra√ß√£o para Cen√°rios de Inicializa√ß√£o Frequente

üì± **Exemplo**: [mobile_quickstart.dart](example/lib/mobile_quickstart.dart)

```dart
// Defini√ß√£o de esquema adequada para aplicativos m√≥veis e desktop de inicializa√ß√£o frequente.
// Identifica com precis√£o as mudan√ßas de esquema e migra automaticamente os dados.
final db = await ToStore.open(
  schemas: [
    const TableSchema(
            name: 'global_settings',
            isGlobal: true,  // Tabela global acess√≠vel a todos os espa√ßos
            fields: [],
    ),
    const TableSchema(
      name: 'users', // Nome da tabela
      tableId: "users",  // Identificador exclusivo para detec√ß√£o de renomea√ß√£o de 100%
      primaryKeyConfig: PrimaryKeyConfig(
        name: 'id',       // Nome da chave prim√°ria
      ),
      fields: [        // Defini√ß√µes de campo (excluindo a chave prim√°ria)
        FieldSchema(
          name: 'username', 
          type: DataType.text, 
          nullable: false, 
          unique: true, // Cria automaticamente um √≠ndice √∫nico
          fieldId: 'username',  // Identificador de campo exclusivo
        ),
        FieldSchema(
          name: 'email', 
          type: DataType.text, 
          nullable: false, 
          unique: true // Cria automaticamente um √≠ndice √∫nico
        ),
        FieldSchema(
          name: 'last_login', 
          type: DataType.datetime,
          createIndex: true // Cria automaticamente um √≠ndice
        ),
      ],
      // Exemplo de √≠ndice composto
      indexes: [
        IndexSchema(fields: ['username', 'last_login']),
      ],
    ),
    // Exemplo de restri√ß√£o de chave estrangeira
    TableSchema(
      name: 'posts',
      primaryKeyConfig: const PrimaryKeyConfig(name: 'id'),
      fields: [
        const FieldSchema(name: 'title', type: DataType.text, nullable: false),
        const FieldSchema(name: 'user_id', type: DataType.integer, nullable: false),
        const FieldSchema(name: 'content', type: DataType.text),
      ],
      foreignKeys: [
        ForeignKeySchema(
          name: 'fk_posts_user',
          fields: ['user_id'],              // Campos da tabela atual
          referencedTable: 'users',         // Tabela referenciada
          referencedFields: ['id'],         // Campos referenciados
          onDelete: ForeignKeyCascadeAction.cascade,  // Exclus√£o em cascata
          onUpdate: ForeignKeyCascadeAction.cascade,  // Atualiza√ß√£o em cascata
        ),
      ],
    ),
  ],
);

// Arquitetura multiespacial - isolamento perfeito de dados de diferentes usu√°rios
await db.switchSpace(spaceName: 'user_123');
```

### Manter estado de login e logout (espa√ßo ativo)

O multi-espa√ßo funciona bem para **dados por usu√°rio**: um espa√ßo por usu√°rio e troca no login. Com **espa√ßo ativo** e as op√ß√µes de **close** voc√™ mant√©m o usu√°rio atual entre rein√≠cios e suporta logout.

- **Manter estado de login**: Ao trocar o usu√°rio para o espa√ßo dele, salve como espa√ßo ativo para que na pr√≥xima abertura com default entre direto nesse espa√ßo (sem precisar ¬´abrir default e depois trocar¬ª).
- **Logout**: No logout, feche o banco com `keepActiveSpace: false` para que a pr√≥xima abertura n√£o abra automaticamente no espa√ßo do usu√°rio anterior.

```dart

// Ap√≥s o login: trocar para o espa√ßo deste usu√°rio e lembrar na pr√≥xima abertura (manter login)
await db.switchSpace(spaceName: 'user_$userId', keepActive: true);

// Opcional: abrir estritamente em default (ex.: s√≥ tela de login) ‚Äî n√£o usar o espa√ßo ativo salvo
// final db = await ToStore.open(..., applyActiveSpaceOnDefault: false);

// No logout: fechar e limpar espa√ßo ativo para que a pr√≥xima abertura use o espa√ßo default
await db.close(keepActiveSpace: false);
```

## Integra√ß√£o no Lado do Servidor

üñ•Ô∏è **Exemplo**: [server_quickstart.dart](example/lib/server_quickstart.dart)

```dart
final db = await ToStore.open();

// Cria√ß√£o massiva de esquemas em tempo de execu√ß√£o
await db.createTables([
  // Tabela de armazenamento de vetores de caracter√≠sticas espaciais 3D
  const TableSchema(
    name: 'spatial_embeddings',
    primaryKeyConfig: PrimaryKeyConfig(
      name: 'id',
      type: PrimaryKeyType.timestampBased,   // PK de timestamp para alta simultaneidade
    ),
    fields: [
      FieldSchema(
        name: 'video_name',
        type: DataType.text,
        nullable: false,
      ),
      FieldSchema(
        name: 'spatial_features',
        type: DataType.vector,                // Tipo de armazenamento vetorial
        vectorConfig: VectorFieldConfig(
          dimensions: 1024,                   // Vetor de alta dimens√£o
          precision: VectorPrecision.float32, 
        ),
      ),
    ],
    indexes: [
      IndexSchema(
        fields: ['video_name'],
        unique: true,
      ),
      IndexSchema(
        type: IndexType.vector,              // √çndice vetorial
        fields: ['spatial_features'],
        vectorConfig: VectorIndexConfig(
          indexType: VectorIndexType.ngh,   // Algoritmo NGH para ANN eficiente
          distanceMetric: VectorDistanceMetric.cosine,
          parameters: {
            'M': 16,
            'efConstruction': 200,
          },
        ),
      ),
    ],
  ),
  // Outras tabelas...
]);

// Atualiza√ß√µes de Esquema Online - Sem interrup√ß√£o para o neg√≥cio
final taskId = await db.updateSchema('users')
  .renameTable('users_new')                // Renomear tabela
  .modifyField(
    'username',
    minLength: 5,
    maxLength: 20,
    unique: true
  )                                        // Modificar atributos de campo
  .renameField('old_name', 'new_name')     // Renomear campo
  .removeField('deprecated_field')         // Remover campo
  .addField('created_at', type: DataType.datetime)  // Adicionar campo
  .removeIndex(fields: ['age'])            // Remover √≠ndice
  .setPrimaryKeyConfig(                    // Alterar config de PK
    const PrimaryKeyConfig(type: PrimaryKeyType.shortCode)
  );
    
// Monitorar progresso da migra√ß√£o
final status = await db.queryMigrationTaskStatus(taskId);
print('Progresso da migra√ß√£o: ${status?.progressPercentage}%');


// Gerenciamento Manual de Cache de Consulta (Lado do Servidor)
// Gerenciado automaticamente em plataformas de cliente.
// Para servidor ou dados em larga escala, use essas APIs para controle preciso.

// Armazenar manualmente o resultado de uma consulta por 5 minutos.
final activeUsers = await db.query('users')
    .where('is_active', '=', true)
    .useQueryCache(const Duration(minutes: 5));

// Invalidar cache espec√≠fica quando os dados mudam.
await db.query('users')
    .where('is_active', '=', true)
    .clearQueryCache();

// Desabilitar explicitamente o cache para consultas com dados em tempo real.
final freshUserData = await db.query('users')
    .where('is_active', '=', true)
    .noQueryCache();
```



## Uso Avan√ßado

O Tostore fornece um conjunto rico de recursos avan√ßados para requisitos complexos:

### Consultas Aninhadas e Filtragem Personalizada
Suporta aninhamento infinito de condi√ß√µes e fun√ß√µes personalizadas flex√≠veis.

```dart
// Aninhamento de condi√ß√µes: (type = 'app' OR (id >= 123 OR fans >= 200))
final idCondition = QueryCondition().where('id', '>=', 123).or().where('fans', '>=', 200);

final result = await db.query('users')
    .condition(
        QueryCondition().whereEqual('type', 'app').or().condition(idCondition)
    )
    .limit(20);

// Fun√ß√£o de condi√ß√£o personalizada
final customResult = await db.query('users')
    .whereCustom((record) => record['tags']?.contains('recomendado') ?? false);
```

### Upsert Inteligente
Atualiza se existir, caso contr√°rio insere.

```dart
// By primary key or unique key in data (no where)
final result = await db.upsert('users', {'id': 1, 'username': 'john', 'email': 'john@example.com'});
await db.upsert('users', {'username': 'john', 'email': 'john@example.com', 'age': 26});
// Batch upsert
await db.batchUpsert('users', [
  {'username': 'a', 'email': 'a@example.com'},
  {'username': 'b', 'email': 'b@example.com'},
], allowPartialErrors: true);
```


### Jun√ß√µes (Joins) e Sele√ß√£o de Campos
```dart
final orders = await db.query('orders')
    .select(['orders.id', 'users.name as user_name'])
    .join('users', 'orders.user_id', '=', 'users.id')
    .where('orders.amount', '>', 1000);
```

### Fluxo (Streaming) e Estat√≠sticas
```dart
// Contar registros
final count = await db.query('users').count();

// Fun√ß√µes de agrega√ß√£o
final totalAge = await db.query('users').where('age', '>', 18).sum('age');
final avgAge = await db.query('users').avg('age');
final maxAge = await db.query('users').max('age');
final minAge = await db.query('users').min('age');

// Agrupamento e filtragem
final result = await db.query('orders')
    .select(['status', Agg.sum('amount', alias: 'total')])
    .groupBy(['status'])
    .having(Agg.sum('amount'), '>', 1000)
    .limit(20);

// Consulta de valores distintos
final uniqueCities = await db.query('users').distinct(['city']);

// Consulta por fluxo (adequada para dados massivos)
db.streamQuery('users').listen((data) => print(data));
```



### Consultas e Pagina√ß√£o Eficiente

O Tostore oferece suporte a pagina√ß√£o de modo duplo:

#### 1. Modo Offset
Adequado para pequenos conjuntos de dados ou quando o salto para uma p√°gina espec√≠fica √© necess√°rio.

```dart
final result = await db.query('users')
    .orderByDesc('created_at')
    .offset(40) // Pular os primeiros 40
    .limit(20); // Pegar 20
```
> [!TIP]
> Quando o `offset` √© muito grande, o banco de dados deve escanear e descartar muitos registros, levando √† degrada√ß√£o do desempenho. Use o **Modo Cursor** para pagina√ß√£o profunda.

#### 2. Modo Cursor de Alto Desempenho
**Recomendado para dados massivos e cen√°rios de rolagem infinita**. Utiliza `nextCursor` para desempenho O(1), garantindo velocidade de consulta constante.

> [!IMPORTANT]
> Se ordenar por um campo n√£o indexado ou para certas consultas complexas, o motor pode voltar para a varredura completa da tabela e retornar um cursor `null` (o que significa que a pagina√ß√£o para essa consulta espec√≠fica ainda n√£o √© suportada).

```dart
// P√°gina 1
final page1 = await db.query('users')
    .orderByDesc('id')
    .limit(20);

// Buscar pr√≥xima p√°gina usando o cursor
if (page1.nextCursor != null) {
  final page2 = await db.query('users')
      .orderByDesc('id')
      .limit(20)
      .cursor(page1.nextCursor); // Buscar diretamente a posi√ß√£o
}

// Retroceder eficientemente com prevCursor
final prevPage = await db.query('users')
    .limit(20)
    .cursor(page2.prevCursor);
```

| Recurso | Modo Offset | Modo Cursor |
| :--- | :--- | :--- |
| **Desempenho** | Diminui conforme a p√°gina aumenta | **Constante (O(1))** |
| **Complexidade** | Dados pequenos, saltos de p√°gina | **Dados massivos, rolagem infinita** |
| **Consist√™ncia** | Altera√ß√µes podem causar saltos | **Perfeita integridade diante de altera√ß√µes** |



### Operadores de consulta

Operadores (insens√≠veis a mai√∫sculas) para `where(field, operator, value)`:

| Operator | Description | Example / Value type |
| :--- | :--- | :--- |
| `=` | Equal | `where('status', '=', 'active')` |
| `!=`, `<>` | Not equal | `where('role', '!=', 'guest')` |
| `>` | Greater than | `where('age', '>', 18)` |
| `>=` | Greater than or equal | `where('score', '>=', 60)` |
| `<` | Less than | `where('price', '<', 100)` |
| `<=` | Less than or equal | `where('quantity', '<=', 10)` |
| `IN` | Value in list | `where('id', 'IN', ['a','b','c'])` ‚Äî value: `List` |
| `NOT IN` | Value not in list | `where('status', 'NOT IN', ['banned'])` ‚Äî value: `List` |
| `BETWEEN` | Between start and end (inclusive) | `where('age', 'BETWEEN', [18, 65])` ‚Äî value: `[start, end]` |
| `LIKE` | Pattern match (`%` any, `_` single char) | `where('name', 'LIKE', '%John%')` ‚Äî value: `String` |
| `NOT LIKE` | Pattern not match | `where('email', 'NOT LIKE', '%@test.com')` ‚Äî value: `String` |
| `IS` | Is null | `where('deleted_at', 'IS', null)` ‚Äî value: `null` |
| `IS NOT` | Is not null | `where('email', 'IS NOT', null)` ‚Äî value: `null` |

### M√©todos de consulta sem√¢nticos (recomendado)

Prefira m√©todos sem√¢nticos em vez de digitar operadores manualmente.

```dart
// Comparison
db.query('users').whereEqual('username', 'John');
db.query('users').whereNotEqual('role', 'guest');
db.query('users').whereGreaterThan('age', 18);
db.query('users').whereGreaterThanOrEqualTo('score', 60);
db.query('users').whereLessThan('price', 100);
db.query('users').whereLessThanOrEqualTo('quantity', 10);

// Membership & range
db.query('users').whereIn('id', ['id1', 'id2']);
db.query('users').whereNotIn('status', ['banned', 'pending']);
db.query('users').whereBetween('age', 18, 65);

// Null checks
db.query('users').whereNull('deleted_at');
db.query('users').whereNotNull('email');

// Pattern match
db.query('users').whereLike('name', '%John%');
db.query('users').whereNotLike('email', '%@temp.');
db.query('users').whereContains('bio', 'flutter');   // LIKE '%flutter%'
db.query('users').whereNotContains('title', 'draft');

// Equivalent to: .where('age', '>', 18).where('name', 'like', '%John%')
final users = await db.query('users')
    .whereGreaterThan('age', 18)
    .whereLike('username', '%John%')
    .orderByDesc('age')
    .limit(20);
```

## Arquitetura Distribu√≠da

```dart
// Configurar N√≥s Distribu√≠dos
final db = await ToStore.open(
  config: DataStoreConfig(
    distributedNodeConfig: const DistributedNodeConfig(
      enableDistributed: true,
      clusterId: 1,
      centralServerUrl: 'http://127.0.0.1:8080',
      accessToken: 'b7628a4f9b4d269b98649129'
    )
  )
);

// Inser√ß√£o em lote de alto desempenho (Batch Insert)
await db.batchInsert('vector_data', [
  {'vector_name': 'face_2365', 'timestamp': DateTime.now()},
  {'vector_name': 'face_2366', 'timestamp': DateTime.now()},
  // ... Registros inseridos eficientemente em lote
]);

// Processar grandes conjuntos de dados por fluxo - Mem√≥ria constante
await for (final record in db.streamQuery('vector_data')
  .where('vector_name', '=', 'face_2366')
  .where('timestamp', '>=', DateTime.now().subtract(Duration(days: 30)))
  .stream) {
  // Processa eficientemente at√© dados em escala TB sem alto consumo de mem√≥ria
  print(record);
}
```

## Exemplos de Chaves Prim√°rias

O Tostore fornece v√°rios algoritmos de chaves prim√°rias distribu√≠das:

- **Sequencial** (PrimaryKeyType.sequential): 238978991
- **Baseado em timestamp** (PrimaryKeyType.timestampBased): 1306866018836946
- **Prefixo de data** (PrimaryKeyType.datePrefixed): 20250530182215887631
- **C√≥digo curto** (PrimaryKeyType.shortCode): 9eXrF0qeXZ

```dart
// Exemplo de configura√ß√£o de chave prim√°ria sequencial
await db.createTables([
  const TableSchema(
    name: 'users',
    primaryKeyConfig: PrimaryKeyConfig(
      type: PrimaryKeyType.sequential,
      sequentialConfig: SequentialIdConfig(
        initialValue: 10000,
        increment: 50,
        useRandomIncrement: true, // Ocultar volume de neg√≥cios
      ),
    ),
    fields: [/* Defini√ß√£o de campos */]
  ),
]);
```


## Opera√ß√µes At√¥micas com Express√µes

O sistema de express√µes fornece atualiza√ß√µes de campo at√¥micas e seguras. Todos os c√°lculos s√£o executados atomicamente no n√≠vel do banco de dados para evitar conflitos de simultaneidade:

```dart
// Incremento Simples: balance = balance + 100
await db.update('accounts', {
  'balance': Expr.field('balance') + Expr.value(100),
}).where('id', '=', accountId);

// C√°lculo Complexo: total = price * quantity + tax
await db.update('orders', {
  'total': Expr.field('price') * Expr.field('quantity') + Expr.field('tax'),
}).where('id', '=', orderId);

// Par√™nteses aninhados: finalPrice = ((price * quantity) + tax) * (1 - discount)
await db.update('orders', {
  'finalPrice': ((Expr.field('price') * Expr.field('quantity')) + Expr.field('tax')) * 
                 (Expr.value(1) - Expr.field('discount')),
}).where('id', '=', orderId);

// Uso de fun√ß√µes: price = min(price, maxPrice)
await db.update('products', {
  'price': Expr.min(Expr.field('price'), Expr.field('maxPrice')),
}).where('id', '=', productId);

// S√≠mbolo de tempo: updatedAt = now()
await db.update('users', {
  'updatedAt': Expr.now(),
}).where('id', '=', userId);
```

## Transa√ß√µes

As transa√ß√µes asseguram a atomicidade de m√∫ltiplas opera√ß√µes: ou todas t√™m sucesso ou todas s√£o revertidas, garantindo a consist√™ncia dos dados.

**Caracter√≠sticas das Transa√ß√µes**:
- Execu√ß√£o at√¥mica de m√∫ltiplas opera√ß√µes.
- Recupera√ß√£o autom√°tica de opera√ß√µes inacabadas ap√≥s um travamento.
- Os dados s√£o salvos com seguran√ßa ao confirmar (commit) com sucesso.

```dart
// Transa√ß√£o b√°sica
final txResult = await db.transaction(() async {
  // Inserir usu√°rio
  await db.insert('users', {
    'username': 'john',
    'email': 'john@example.com',
    'fans': 100,
  });
  
  // Atualiza√ß√£o at√¥mica usando express√µes
  await db.update('users', {
    'fans': Expr.field('fans') + Expr.value(50),
  }).where('username', '=', 'john');
  
  // Se qualquer opera√ß√£o falhar, todas as altera√ß√µes s√£o revertidas automaticamente.
});

if (txResult.isSuccess) {
  print('Transa√ß√£o confirmada com sucesso');
} else {
  print('Transa√ß√£o revertida: ${txResult.error?.message}');
}

// Revers√£o autom√°tica em caso de erro
final txResult2 = await db.transaction(() async {
  await db.insert('users', {
    'username': 'jane',
    'email': 'jane@example.com',
  });
  throw Exception('Erro de l√≥gica de neg√≥cio'); // Ativa a revers√£o
}, rollbackOnError: true);
```

## Configura√ß√£o de Seguran√ßa

**Mecanismos de Seguran√ßa de Dados**:
- Mecanismos de dupla prote√ß√£o garantem que os dados nunca sejam perdidos.
- Recupera√ß√£o autom√°tica de travamentos para opera√ß√µes incompletas.
- Persist√™ncia segura instant√¢nea ao sucesso da opera√ß√£o.
- Criptografia de alta resist√™ncia protege dados sens√≠veis.

> [!WARNING]
> **Gest√£o de Chaves**: **`encodingKey`** pode ser alterada livremente; o motor migrar√° os dados automaticamente ao alter√°-la, sem risco de perda. **`encryptionKey`** n√£o deve ser alterada arbitrariamente: alter√°-la tornar√° os dados antigos ileg√≠veis, a menos que uma migra√ß√£o seja realizada. N√£o codifique chaves sens√≠veis; obtenha-as de um servidor seguro.

```dart
final db = await ToStore.open(
  config: DataStoreConfig(
    encryptionConfig: EncryptionConfig(
      // Algoritmos suportados: none, xorObfuscation, chacha20Poly1305, aes256Gcm
      encryptionType: EncryptionType.chacha20Poly1305, 
      
      // Chave de codifica√ß√£o (pode ser alterada livremente; os dados s√£o migrados automaticamente)
      encodingKey: 'Sua-Chave-De-Codificacao-De-32-Bytes...', 
      
      // Chave de criptografia para dados cr√≠ticos (n√£o alterar arbitrariamente; dados antigos ileg√≠veis salvo migra√ß√£o)
      encryptionKey: 'Sua-Chave-De-Criptografia-Segura...',
      
      // Vincula√ß√£o ao dispositivo (Baseada em caminho)
      // Quando habilitado, as chaves s√£o vinculadas ao caminho e √†s caracter√≠sticas do dispositivo.
      // Aumenta a seguran√ßa contra a c√≥pia de arquivos de banco de dados.
      deviceBinding: false, 
    ),
    // Registro pr√©vio √† grava√ß√£o (WAL) habilitado por padr√£o
    enableJournal: true, 
    // For√ßar o despejo em disco no commit (desativar para maior desempenho)
    persistRecoveryOnCommit: true,
  ),
);
```

### Criptografia em n√≠vel de valor (ToCrypto)

A criptografia de toda a base de dados acima criptografa todas as tabelas e √≠ndices e pode afetar o desempenho geral. Para criptografar apenas campos sens√≠veis, use **ToCrypto**: √© independente do banco de dados (n√£o requer inst√¢ncia db). Voc√™ codifica ou decodifica os valores antes de escrever ou ap√≥s ler; a chave √© gerenciada inteiramente pelo seu app. A sa√≠da √© Base64, adequada para colunas JSON ou TEXT.

- **key** (obrigat√≥rio): `String` ou `Uint8List`. Se n√£o for 32 bytes, uma chave de 32 bytes √© derivada via SHA-256.
- **type** (opcional): Tipo de criptografia [ToCryptoType]: [ToCryptoType.chacha20Poly1305] ou [ToCryptoType.aes256Gcm]. Padr√£o [ToCryptoType.chacha20Poly1305]. Omitir para usar o padr√£o.
- **aad** (opcional): Dados autenticados adicionais ‚Äî `Uint8List`. Se passado na codifica√ß√£o, voc√™ deve passar os mesmos bytes na decodifica√ß√£o (ex.: nome da tabela + campo para vincular contexto). Omitir para uso simples.

```dart
const key = 'my-secret-key';
// Codificar: texto plano ‚Üí Base64 cifrado (armazenar em DB ou JSON)
final cipher = ToCrypto.encode('sensitive data', key: key);
// Decodificar ao ler
final plain = ToCrypto.decode(cipher, key: key);

// Opcional: vincular contexto com aad (mesmo aad na codifica√ß√£o e decodifica√ß√£o)
final aad = Uint8List.fromList(utf8.encode('users:id_number'));
final cipher2 = ToCrypto.encode('secret', key: key, aad: aad);
final plain2 = ToCrypto.decode(cipher2, key: key, aad: aad);
```

## Desempenho e Experi√™ncia

### Especifica√ß√µes de Desempenho

- **Velocidade de In√≠cio**: In√≠cio instant√¢neo e exibi√ß√£o de dados mesmo com mais de 100M de registros em smartphones t√≠picos.
- **Desempenho de Consulta**: Independente da escala, desempenho de busca ultrarr√°pido constante.
- **Seguran√ßa de Dados**: Garantias de transa√ß√£o ACID + recupera√ß√£o de falhas para zero perda de dados.

### Recomenda√ß√µes

- üì± **Projeto de Exemplo**: Um exemplo completo de aplicativo Flutter √© fornecido no diret√≥rio `example`.
- üöÄ **Produ√ß√£o**: Use o modo Release para desempenho superior ao modo Debug.
- ‚úÖ **Testes Padr√£o**: Todas as funcionalidades principais passaram nos testes de integra√ß√£o.

### V√≠deos de demonstra√ß√£o

<p align="center">
  <img src="../media/basic-demo.gif" alt="Demo b√°sica de desempenho do Tostore" width="320" />
  </p>

- **Demo b√°sica de desempenho** (<a href="../media/basic-demo.mp4?raw=1" target="_blank" rel="noopener">basic-demo.mp4</a>): A pr√©via em GIF pode estar cortada; clique no v√≠deo para ver a demo completa. Mostra que, mesmo em um smartphone comum com mais de 100‚ÄØM de registros, o tempo de inicializa√ß√£o do app, a pagina√ß√£o e as consultas permanecem sempre est√°veis e fluidas. Desde que haja armazenamento suficiente, dispositivos de borda conseguem lidar com conjuntos de dados em escala de TB/PB mantendo a lat√™ncia de intera√ß√£o consistentemente baixa.

<p align="center">
  <img src="../media/disaster-recovery.gif" alt="Teste de recupera√ß√£o de desastres do Tostore" width="320" />
  </p>
  
- **Teste de recupera√ß√£o de desastres** (<a href="../media/disaster-recovery.mp4?raw=1" target="_blank" rel="noopener">disaster-recovery.mp4</a>): Interrompe deliberadamente o processo durante cargas intensas de grava√ß√£o para simular travamentos e quedas de energia. Mesmo quando dezenas de milhares de opera√ß√µes de escrita s√£o abruptamente interrompidas, o Tostore consegue se recuperar muito rapidamente em um smartphone t√≠pico, sem afetar a pr√≥xima inicializa√ß√£o nem a disponibilidade dos dados.




Se o Tostore te ajuda, por favor nos d√™ uma ‚≠êÔ∏è




## Roadmap

O Tostore est√° desenvolvendo ativamente recursos para aprimorar a infraestrutura de dados na era da IA:

- **Vetores de Alta Dimens√£o**: Adicionando recupera√ß√£o de vetores e algoritmos de busca sem√¢ntica.
- **Dados Multimodais**: Fornecendo processamento de ponta a ponta, de dados brutos a vetores de caracter√≠sticas.
- **Estruturas de Dados de Grafos**: Suporte para armazenamento e consulta eficiente de grafos de conhecimento e redes relacionais complexas.





> **Recomenda√ß√£o**: Desenvolvedores m√≥veis tamb√©m podem considerar o [Framework Toway](https://github.com/tocreator/toway), uma solu√ß√£o full-stack que automatiza solicita√ß√µes de dados, carregamento, armazenamento, cache e exibi√ß√£o.




---

## Recursos Adicionais

- üìñ **Documenta√ß√£o**: [Wiki](https://github.com/tocreator/tostore)
- üì¢ **Feedback**: [GitHub Issues](https://github.com/tocreator/tostore/issues)
- üí¨ **Discuss√£o**: [GitHub Discussions](https://github.com/tocreator/tostore/discussions)


## Licen√ßa

Este projeto est√° sob a Licen√ßa Apache 2.0 - veja o arquivo [LICENSE](LICENSE) para detalhes.

---
