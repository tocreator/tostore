# Tostore

[English](../../README.md) | [ç®€ä½“ä¸­æ–‡](README.zh-CN.md) | [æ—¥æœ¬èªž](README.ja.md) | [í•œêµ­ì–´](README.ko.md) | [EspaÃ±ol](README.es.md) | [PortuguÃªs (Brasil)](README.pt-BR.md) | [Ð ÑƒÑÑÐºÐ¸Ð¹](README.ru.md) | [Deutsch](README.de.md) | FranÃ§ais | [Italiano](README.it.md) | [TÃ¼rkÃ§e](README.tr.md)

[![pub package](https://img.shields.io/pub/v/tostore.svg)](https://pub.dev/packages/tostore)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Platform](https://img.shields.io/badge/Platform-Flutter-02569B?logo=flutter)](https://flutter.dev)
[![Dart Version](https://img.shields.io/badge/Dart-3.5+-00B4AB.svg?logo=dart)](https://dart.dev)


## Pourquoi choisir Tostore ?

Tostore est le seul moteur de stockage haute performance pour les bases de donnÃ©es vectorielles distribuÃ©es dans l'Ã©cosystÃ¨me Dart/Flutter. Utilisant une architecture de type rÃ©seau neuronal, il prÃ©sente une interconnectivitÃ© intelligente et une collaboration entre les nÅ“uds, prenant en charge une mise Ã  l'Ã©chelle horizontale infinie. Il construit un rÃ©seau de topologie de donnÃ©es flexible et fournit une identification prÃ©cise des changements de schÃ©ma, une protection par cryptage et une isolation des donnÃ©es multi-espaces. Tostore exploite pleinement les CPU multi-cÅ“urs pour un traitement parallÃ¨le extrÃªme et prend nativement en charge la collaboration multiplateforme, des appareils pÃ©riphÃ©riques (edge) mobiles au cloud. Avec divers algorithmes de clÃ©s primaires distribuÃ©es, il fournit une base de donnÃ©es puissante pour des scÃ©narios tels que la rÃ©alitÃ© virtuelle immersive, l'interaction multimodale, l'informatique spatiale, l'IA gÃ©nÃ©rative et la modÃ©lisation de l'espace vectoriel sÃ©mantique.

Alors que l'IA gÃ©nÃ©rative et l'informatique spatiale dÃ©placent le centre de gravitÃ© vers la pÃ©riphÃ©rie (edge), les terminaux Ã©voluent de simples afficheurs de contenu vers des noyaux de gÃ©nÃ©ration locale, de perception environnementale et de prise de dÃ©cision en temps rÃ©el. Les bases de donnÃ©es intÃ©grÃ©es traditionnelles Ã  fichier unique sont limitÃ©es par leur conception architecturale, luttant souvent pour rÃ©pondre aux exigences de rÃ©ponse immÃ©diate des applications intelligentes face Ã  des Ã©critures Ã  haute concurrence, une recherche vectorielle massive et une gÃ©nÃ©ration collaborative cloud-edge. Tostore est nÃ© pour les appareils pÃ©riphÃ©riques, leur confÃ©rant des capacitÃ©s de stockage distribuÃ© suffisantes pour supporter une IA locale complexe et un flux de donnÃ©es Ã  grande Ã©chelle, rÃ©alisant ainsi une vÃ©ritable collaboration approfondie entre le cloud et le edge.

**RÃ©sistant aux coupures de courant et aux plantages** : MÃªme en cas de coupure de courant inattendue ou de plantage de l'application, les donnÃ©es peuvent Ãªtre automatiquement rÃ©cupÃ©rÃ©es, rÃ©alisant une perte zÃ©ro rÃ©elle. Lorsqu'une opÃ©ration sur les donnÃ©es rÃ©pond, les donnÃ©es ont dÃ©jÃ  Ã©tÃ© sauvegardÃ©es en toute sÃ©curitÃ©, Ã©liminant tout risque de perte de donnÃ©es.

**DÃ©passement des limites de performance** : Les tests de performance montrent que mÃªme avec 10 millions d'enregistrements, un smartphone classique peut dÃ©marrer immÃ©diatement et afficher les rÃ©sultats de recherche instantanÃ©ment. Quelle que soit la taille du volume de donnÃ©es, vous bÃ©nÃ©ficiez d'une expÃ©rience fluide qui dÃ©passe de loin celle des bases de donnÃ©es traditionnelles.




...... Du bout des doigts aux applications cloud, Tostore vous aide Ã  libÃ©rer la puissance de calcul des donnÃ©es et Ã  prÃ©parer l'avenir ......




## CaractÃ©ristiques de Tostore

- ðŸŒ **Support fluide de toutes les plateformes**
  - ExÃ©cutez le mÃªme code sur toutes les plateformes, des applications mobiles aux serveurs cloud.
  - S'adapte intelligemment aux diffÃ©rents backends de stockage des plateformes (IndexedDB, systÃ¨me de fichiers, etc.).
  - Interface API unifiÃ©e pour une synchronisation de donnÃ©es multiplateforme sans souci.
  - Flux de donnÃ©es fluide des appareils pÃ©riphÃ©riques aux serveurs cloud.
  - Calcul vectoriel local sur les appareils pÃ©riphÃ©riques, rÃ©duisant la latence du rÃ©seau et la dÃ©pendance au cloud.

- ðŸ§  **Architecture distribuÃ©e de type rÃ©seau neuronal**
  - Structure de topologie de nÅ“uds interconnectÃ©s pour une organisation efficace du flux de donnÃ©es.
  - MÃ©canisme de partitionnement de donnÃ©es haute performance pour un vÃ©ritable traitement distribuÃ©.
  - Ã‰quilibrage dynamique intelligent de la charge de travail pour maximiser l'utilisation des ressources.
  - Mise Ã  l'Ã©chelle horizontale infinie des nÅ“uds pour construire facilement des rÃ©seaux de donnÃ©es complexes.

- âš¡ **CapacitÃ© de traitement parallÃ¨le ultime**
  - Lecture/Ã©criture parallÃ¨le rÃ©elle utilisant les Isolates, fonctionnant Ã  plein rÃ©gime sur les CPU multi-cÅ“urs.
  - La planification intelligente des ressources Ã©quilibre automatiquement la charge pour maximiser les performances multi-cÅ“urs.
  - Le rÃ©seau informatique multi-nÅ“uds collaboratif double l'efficacitÃ© du traitement des tÃ¢ches.
  - Le cadre de planification sensible aux ressources optimise automatiquement les plans d'exÃ©cution pour Ã©viter les conflits de ressources.
  - L'interface de requÃªte en flux (streaming) gÃ¨re facilement des ensembles de donnÃ©es massifs.

- ðŸ”‘ **Divers algorithmes de clÃ©s primaires distribuÃ©es**
  - Algorithme d'incrÃ©mentation sÃ©quentielle - Ajustez librement les tailles de pas alÃ©atoires pour cacher l'Ã©chelle de l'activitÃ©.
  - Algorithme basÃ© sur l'horodatage (Timestamp) - Le meilleur choix pour les scÃ©narios Ã  haute concurrence.
  - Algorithme de prÃ©fixe de date - Support parfait pour l'affichage de donnÃ©es sur une pÃ©riode donnÃ©e.
  - Algorithme de code court - GÃ©nÃ¨re des identifiants uniques courts et faciles Ã  lire.

- ðŸ”„ **Migration intelligente de schÃ©ma et intÃ©gritÃ© des donnÃ©es**
  - Identifie avec prÃ©cision les champs de table renommÃ©s sans aucune perte de donnÃ©es.
  - DÃ©tection automatique des changements de schÃ©ma et migration de donnÃ©es en quelques millisecondes.
  - Mises Ã  jour sans interruption, invisibles pour l'entreprise.
  - StratÃ©gies de migration sÃ©curisÃ©es pour les changements de structure complexes.
  - Validation automatique des contraintes de clÃ©s Ã©trangÃ¨res avec support d'opÃ©rations en cascade assurant l'intÃ©gritÃ© rÃ©fÃ©rentielle.

- ðŸ›¡ï¸ **SÃ©curitÃ© et durabilitÃ© de niveau entreprise**
  - MÃ©canisme de double protection : l'enregistrement en temps rÃ©el des changements de donnÃ©es garantit que rien n'est jamais perdu.
  - RÃ©cupÃ©ration automatique aprÃ¨s plantage : reprend automatiquement les opÃ©rations inachevÃ©es aprÃ¨s une coupure de courant ou un plantage.
  - Garantie de cohÃ©rence des donnÃ©es : les opÃ©rations rÃ©ussissent entiÃ¨rement ou sont totalement annulÃ©es (rollback).
  - Mises Ã  jour calculÃ©es atomiques : le systÃ¨me d'expressions supporte des calculs complexes, exÃ©cutÃ©s de maniÃ¨re atomique pour Ã©viter les conflits de concurrence.
  - Persistance sÃ©curisÃ©e instantanÃ©e : les donnÃ©es sont sauvegardÃ©es en toute sÃ©curitÃ© dÃ¨s que l'opÃ©ration rÃ©ussit.
  - L'algorithme de cryptage haute rÃ©sistance ChaCha20Poly1305 protÃ¨ge les donnÃ©es sensibles.
  - Cryptage de bout en bout pour une sÃ©curitÃ© pendant tout le stockage et la transmission.

- ðŸš€ **Cache intelligent et performance de recherche**
  - MÃ©canisme de cache intelligent Ã  plusieurs niveaux pour une recherche de donnÃ©es ultra-rapide.
  - StratÃ©gies de cache profondÃ©ment intÃ©grÃ©es au moteur de stockage.
  - La mise Ã  l'Ã©chelle adaptative maintient des performances stables Ã  mesure que le volume de donnÃ©es augmente.
  - Notifications de changement de donnÃ©es en temps rÃ©el avec mise Ã  jour automatique des rÃ©sultats de recherche.

- ðŸ”„ **Flux de travail de donnÃ©es intelligent**
  - L'architecture multi-espaces assure l'isolation des donnÃ©es tout en permettant un partage global.
  - Distribution intelligente de la charge de travail entre les nÅ“uds de calcul.
  - Fournit une base solide pour l'entraÃ®nement et l'analyse de donnÃ©es Ã  grande Ã©chelle.


## Installation

> [!IMPORTANT]
> **Mise Ã  niveau depuis v2.x ?** Veuillez lire le [Guide de mise Ã  niveau v3.0](../UPGRADE_GUIDE_v3.md) pour les Ã©tapes de migration critiques et les changements importants.

Ajoutez `tostore` comme dÃ©pendance dans votre `pubspec.yaml` :

```yaml
dependencies:
  tostore: any # Veuillez utiliser la version la plus rÃ©cente
```

## DÃ©marrage rapide

> [!IMPORTANT]
> **La dÃ©finition du schÃ©ma de table est la premiÃ¨re Ã©tape** : Avant d'effectuer des opÃ©rations CRUD, vous devez dÃ©finir le schÃ©ma de la table. La mÃ©thode de dÃ©finition spÃ©cifique dÃ©pend de votre scÃ©nario :
> - **Mobile/Bureau** : RecommandÃ© [DÃ©finition statique](#intÃ©gration-pour-les-scÃ©narios-de-dÃ©marrage-frÃ©quent).
> - **CÃ´tÃ© serveur** : RecommandÃ© [CrÃ©ation dynamique](#intÃ©gration-cÃ´tÃ©-serveur).

```dart
// 1. Initialiser la base de donnÃ©es
final db = await ToStore.open();

// 2. InsÃ©rer des donnÃ©es
await db.insert('users', {
  'username': 'John',
  'email': 'john@example.com',
  'age': 25,
});

// 3. RequÃªtes chaÃ®nÃ©es (Supporte =, !=, >, <, LIKE, IN, etc.)
final users = await db.query('users')
    .where('age', '>', 20)
    .where('username', 'like', '%John%')
    .orderByDesc('age')
    .limit(20);

// 4. Mettre Ã  jour et Supprimer
await db.update('users', {'age': 26}).where('username', '=', 'John');
await db.delete('users').where('username', '=', 'John');

// 5. Ã‰coute en temps rÃ©el (l'UI se met Ã  jour automatiquement)
db.query('users').where('age', '>', 18).watch().listen((users) {
  print('Utilisateurs correspondants mis Ã  jour : $users');
});
```

### Stockage ClÃ©-Valeur (KV)
AdaptÃ© aux scÃ©narios ne nÃ©cessitant pas de dÃ©finir des tables structurÃ©es. C'est simple, pratique et inclut un store KV haute performance intÃ©grÃ© pour les configurations, les Ã©tats et autres donnÃ©es Ã©parses. Les donnÃ©es dans des espaces (Spaces) diffÃ©rents sont naturellement isolÃ©es mais peuvent Ãªtre partagÃ©es globalement.

```dart
// 1. DÃ©finir des paires clÃ©-valeur (Supporte String, int, bool, double, Map, List, etc.)
await db.setValue('theme', 'dark');
await db.setValue('login_attempts', 3);

// 2. RÃ©cupÃ©rer des donnÃ©es
final theme = await db.getValue('theme'); // 'dark'

// 3. Supprimer des donnÃ©es
await db.removeValue('theme');

// 4. ClÃ©-valeur globale (partagÃ©e entre les Spaces)
// Par dÃ©faut, les donnÃ©es KV sont spÃ©cifiques Ã  l'espace. Utilisez isGlobal: true pour le partage.
await db.setValue('app_version', '1.0.0', isGlobal: true);
final version = await db.getValue('app_version', isGlobal: true);
```



## IntÃ©gration pour les scÃ©narios de dÃ©marrage frÃ©quent

```dart
// DÃ©finition de schÃ©ma adaptÃ©e aux scÃ©narios de dÃ©marrage frÃ©quent (applications mobiles/bureau).
// Identifie prÃ©cisÃ©ment les changements de schÃ©ma et migre automatiquement les donnÃ©es.
final db = await ToStore.open(
  schemas: [
    const TableSchema(
            name: 'global_settings',
            isGlobal: true,  // Table globale accessible par tous les espaces
            fields: [],
    ),
    const TableSchema(
      name: 'users', // Nom de la table
      tableId: "users",  // Identifiant unique pour une dÃ©tection Ã  100% des renommages
      primaryKeyConfig: PrimaryKeyConfig(
        name: 'id',       // Nom de la clÃ© primaire
      ),
      fields: [        // DÃ©finition des champs (hors clÃ© primaire)
        FieldSchema(
          name: 'username', 
          type: DataType.text, 
          nullable: false, 
          unique: true,
          fieldId: 'username',  // Identifiant unique du champ
        ),
        FieldSchema(
          name: 'email', 
          type: DataType.text, 
          nullable: false, 
          unique: true
        ),
        FieldSchema(
          name: 'last_login', 
          type: DataType.datetime
        ),
      ],
      indexes: [ // DÃ©finition des index
        IndexSchema(fields: ['username']),
        IndexSchema(fields: ['email']),
      ],
    ),
    // Exemple de contrainte de clÃ© Ã©trangÃ¨re
    TableSchema(
      name: 'posts',
      primaryKeyConfig: const PrimaryKeyConfig(name: 'id'),
      fields: [
        const FieldSchema(name: 'title', type: DataType.text, nullable: false),
        const FieldSchema(name: 'user_id', type: DataType.integer, nullable: false),
        const FieldSchema(name: 'content', type: DataType.text),
      ],
      foreignKeys: [
        ForeignKeySchema(
          name: 'fk_posts_user',
          fields: ['user_id'],              // Champs de la table actuelle
          referencedTable: 'users',         // Table rÃ©fÃ©rencÃ©e
          referencedFields: ['id'],         // Champs rÃ©fÃ©rencÃ©s
          onDelete: ForeignKeyCascadeAction.cascade,  // Suppression en cascade
          onUpdate: ForeignKeyCascadeAction.cascade,  // Mise Ã  jour en cascade
        ),
      ],
    ),
  ],
);

// Architecture multi-espaces - isolation parfaite des donnÃ©es des diffÃ©rents utilisateurs
await db.switchSpace(spaceName: 'user_123');
```

## IntÃ©gration cÃ´tÃ© serveur

```dart
// CrÃ©ation massive de schÃ©mas au runtime
await db.createTables([
  // Table de stockage des vecteurs de caractÃ©ristiques spatiales 3D
  const TableSchema(
    name: 'spatial_embeddings',
    primaryKeyConfig: PrimaryKeyConfig(
      name: 'id',
      type: PrimaryKeyType.timestampBased,   // PK basÃ©e sur l'horodatage pour haute concurrence
    ),
    fields: [
      FieldSchema(
        name: 'video_name',
        type: DataType.text,
        nullable: false,
      ),
      FieldSchema(
        name: 'spatial_features',
        type: DataType.vector,                // Type de stockage vectoriel
        vectorConfig: VectorFieldConfig(
          dimensions: 1024,                   // Vecteur haute dimension
          precision: VectorPrecision.float32, 
        ),
      ),
    ],
    indexes: [
      IndexSchema(
        fields: ['video_name'],
        unique: true,
      ),
      IndexSchema(
        type: IndexType.vector,              // Index vectoriel
        fields: ['spatial_features'],
        vectorConfig: VectorIndexConfig(
          indexType: VectorIndexType.hnsw,   // Algorithme HNSW pour recherche ANN efficace
          distanceMetric: VectorDistanceMetric.cosine,
          parameters: {
            'M': 16,
            'efConstruction': 200,
          },
        ),
      ),
    ],
  ),
  // Autres tables...
]);

// Mises Ã  jour de schÃ©ma en ligne - Transparent pour l'entreprise
final taskId = await db.updateSchema('users')
  .renameTable('users_new')                // Renommer la table
  .modifyField(
    'username',
    minLength: 5,
    maxLength: 20,
    unique: true
  )                                        // Modifier les propriÃ©tÃ©s d'un champ
  .renameField('old_name', 'new_name')     // Renommer un champ
  .removeField('deprecated_field')         // Supprimer un champ
  .addField('created_at', type: DataType.datetime)  // Ajouter un champ
  .removeIndex(fields: ['age'])            // Supprimer un index
  .setPrimaryKeyConfig(                    // Modifier la config PK
    const PrimaryKeyConfig(type: PrimaryKeyType.shortCode)
  );
    
// Suivre la progression de la migration
final status = await db.queryMigrationTaskStatus(taskId);
print('Progression de la migration : ${status?.progressPercentage}%');


// Gestion manuelle du cache de requÃªtes (Serveur)
// Pour les requÃªtes sur les clÃ©s primaires ou les champs indexÃ©s (requÃªtes d'Ã©galitÃ©, IN), les performances sont dÃ©jÃ  extrÃªmes et la gestion manuelle du cache est gÃ©nÃ©ralement inutile.

// Stocker manuellement le rÃ©sultat d'une requÃªte pendant 5 minutes.
final activeUsers = await db.query('users')
    .where('is_active', '=', true)
    .useQueryCache(const Duration(minutes: 5));

// Invalider un cache spÃ©cifique quand les donnÃ©es changent.
await db.query('users')
    .where('is_active', '=', true)
    .clearQueryCache();

// DÃ©sactiver explicitement le cache pour les requÃªtes nÃ©cessitant des donnÃ©es en temps rÃ©el.
final freshUserData = await db.query('users')
    .where('is_active', '=', true)
    .noQueryCache();
```



## Utilisation avancÃ©e

Tostore offre un riche ensemble de fonctionnalitÃ©s avancÃ©es :

### RequÃªtes imbriquÃ©es et filtrage personnalisÃ©
Supporte l'imbrication infinie de conditions et des fonctions personnalisÃ©es flexibles.

```dart
// Imbrication de conditions : (type = 'app' OR (id >= 123 OR fans >= 200))
final idCondition = QueryCondition().where('id', '>=', 123).or().where('fans', '>=', 200);

final result = await db.query('users')
    .condition(
        QueryCondition().whereEqual('type', 'app').or().condition(idCondition)
    )
    .limit(20);

// Fonction de condition personnalisÃ©e
final customResult = await db.query('users')
    .whereCustom((record) => record['tags']?.contains('recommendation') ?? false);
```

### Upsert intelligent
Met Ã  jour si l'enregistrement existe, sinon l'insÃ¨re.

```dart
await db.upsert('users', {
  'email': 'john@example.com',
  'name': 'John New'
}).where('email', '=', 'john@example.com');
```


### Joins et sÃ©lection de champs
```dart
final orders = await db.query('orders')
    .select(['orders.id', 'users.name as user_name'])
    .join('users', 'orders.user_id', '=', 'users.id')
    .where('orders.amount', '>', 1000)
    .limit(20);
```

### Streaming et statistiques
```dart
// Compter les enregistrements
final count = await db.query('users').count();

// RequÃªte en streaming (adaptÃ© aux donnÃ©es massives)
db.streamQuery('users').listen((data) => print(data));
```



### RequÃªtes et pagination efficace

> [!TIP]
> **SpÃ©cifiez explicitement `limit` pour de meilleures performances** : Il est fortement recommandÃ© de toujours spÃ©cifier un `limit` lors des requÃªtes. S'il est omis, le moteur limite par dÃ©faut Ã  1000 enregistrements. Bien que le cÅ“ur de la requÃªte soit extrÃªmement rapide, la sÃ©rialisation d'un grand nombre d'enregistrements dans des applications sensibles Ã  l'interface utilisateur peut entraÃ®ner une latence inutile.

Tostore offre deux modes de pagination :

#### 1. Mode Offset
AdaptÃ© aux jeux de donnÃ©es rÃ©duits ou lorsqu'un saut de page prÃ©cis est requis.

```dart
final result = await db.query('users')
    .orderByDesc('created_at')
    .offset(40) // Sauter les 40 premiers
    .limit(20); // Prendre 20
```
> [!TIP]
> Quand l'`offset` est trÃ¨s grand, la base de donnÃ©es doit scanner et ignorer de nombreux enregistrements, ce qui dÃ©grade les performances. Utilisez le **Mode Cursor** pour une pagination profonde.

#### 2. Mode Cursor haute performance
**RecommandÃ© pour les donnÃ©es massives et le scroll infini**. Utilise `nextCursor` pour des performances en O(1), assurant une vitesse de requÃªte constante.

> [!IMPORTANT]
> En cas de tri sur un champ non indexÃ© ou pour certaines requÃªtes complexes, le moteur peut revenir Ã  un scan complet et renvoyer un curseur `null` (ce qui signifie que la pagination pour cette requÃªte spÃ©cifique n'est pas encore supportÃ©e).

```dart
// Page 1
final page1 = await db.query('users')
    .orderByDesc('id')
    .limit(20);

// RÃ©cupÃ©rer la page suivante via le curseur
if (page1.nextCursor != null) {
  final page2 = await db.query('users')
      .orderByDesc('id')
      .limit(20)
      .cursor(page1.nextCursor); // Atteint directement la position
}

// Revenir en arriÃ¨re efficacement avec prevCursor
final prevPage = await db.query('users')
    .limit(20)
    .cursor(page2.prevCursor);
```

| CaractÃ©ristique | Mode Offset | Mode Cursor |
| :--- | :--- | :--- |
| **Performance** | Diminue quand les pages augmentent | **Constante (O(1))** |
| **ComplexitÃ©** | Petites donnÃ©es, saut de page | **DonnÃ©es massives, scroll infini** |
| **CohÃ©rence** | Les changements de donnÃ©es peuvent causer des doublons | **Ã‰vite les doublons/oublis dus aux changements** |





## Architecture distribuÃ©e

```dart
// Configurer les nÅ“uds distribuÃ©s
final db = await ToStore.open(
  config: DataStoreConfig(
    distributedNodeConfig: const DistributedNodeConfig(
      enableDistributed: true,
      clusterId: 1,
      centralServerUrl: 'http://127.0.0.1:8080',
      accessToken: 'b7628a4f9b4d269b98649129'
    )
  )
);

// Insertion massive haute performance (Batch Insert)
await db.batchInsert('vector_data', [
  {'vector_name': 'face_2365', 'timestamp': DateTime.now()},
  {'vector_name': 'face_2366', 'timestamp': DateTime.now()},
  // ... Enregistrements insÃ©rÃ©s par lot efficacement
]);

// Traiter des jeux de donnÃ©es massifs en streaming - consommation mÃ©moire constante
await for (final record in db.streamQuery('vector_data')
  .where('vector_name', '=', 'face_2366')
  .where('timestamp', '>=', DateTime.now().subtract(Duration(days: 30)))
  .stream) {
  // Traite efficacement mÃªme des donnÃ©es Ã  l'Ã©chelle du To sans consommation mÃ©moire excessive
  print(record);
}
```

## Exemples de types de clÃ©s primaires

Tostore propose plusieurs algorithmes de clÃ©s primaires :

- **SÃ©quentielle** (PrimaryKeyType.sequential) : 238978991
- **BasÃ©e sur l'horodatage** (PrimaryKeyType.timestampBased) : 1306866018836946
- **PrÃ©fixe de date** (PrimaryKeyType.datePrefixed) : 20250530182215887631
- **Code court** (PrimaryKeyType.shortCode) : 9eXrF0qeXZ

```dart
// Exemple de configuration de clÃ© primaire sÃ©quentielle
await db.createTables([
  const TableSchema(
    name: 'users',
    primaryKeyConfig: PrimaryKeyConfig(
      type: PrimaryKeyType.sequential,
      sequentialConfig: SequentialIdConfig(
        initialValue: 10000,
        increment: 50,
        useRandomIncrement: true, // Masque le volume d'activitÃ©
      ),
    ),
    fields: [/* DÃ©finition des champs */]
  ),
]);
```


## OpÃ©rations atomiques avec expressions

Le systÃ¨me d'expressions permet des mises Ã  jour de champs atomiques et sÃ»res. Tous les calculs sont exÃ©cutÃ©s de maniÃ¨re atomique au niveau de la base de donnÃ©es :

```dart
// IncrÃ©ment simple : balance = balance + 100
await db.update('accounts', {
  'balance': Expr.field('balance') + Expr.value(100),
}).where('id', '=', accountId);

// Calcul complexe : total = price * quantity + tax
await db.update('orders', {
  'total': Expr.field('price') * Expr.field('quantity') + Expr.field('tax'),
}).where('id', '=', orderId);

// ParenthÃ¨ses imbriquÃ©es : finalPrice = ((price * quantity) + tax) * (1 - discount)
await db.update('orders', {
  'finalPrice': ((Expr.field('price') * Expr.field('quantity')) + Expr.field('tax')) * 
                 (Expr.value(1) - Expr.field('discount')),
}).where('id', '=', orderId);

// Utilisation de fonctions : price = min(price, maxPrice)
await db.update('products', {
  'price': Expr.min(Expr.field('price'), Expr.field('maxPrice')),
}).where('id', '=', productId);

// Horodatage : updatedAt = now()
await db.update('users', {
  'updatedAt': Expr.now(),
}).where('id', '=', userId);
```

## Transactions

Les transactions garantissent l'atomicitÃ© de plusieurs opÃ©rations : soit tout rÃ©ussit, soit tout est annulÃ©, garantissant la cohÃ©rence des donnÃ©es.

**CaractÃ©ristiques des transactions** :
- ExÃ©cution atomique de plusieurs opÃ©rations.
- RÃ©cupÃ©ration automatique des opÃ©rations inachevÃ©es aprÃ¨s un plantage.
- Sauvegarde sÃ©curisÃ©e des donnÃ©es lors de la validation (commit).

```dart
// Transaction basique
final txResult = await db.transaction(() async {
  // InsÃ©rer un utilisateur
  await db.insert('users', {
    'username': 'john',
    'email': 'john@example.com',
    'fans': 100,
  });
  
  // Mise Ã  jour atomique via expressions
  await db.update('users', {
    'fans': Expr.field('fans') + Expr.value(50),
  }).where('username', '=', 'john');
  
  // En cas d'Ã©chec, tous les changements sont annulÃ©s automatiquement.
});

if (txResult.isSuccess) {
  print('Transaction validÃ©e avec succÃ¨s');
} else {
  print('Transaction annulÃ©e : ${txResult.error?.message}');
}

// Annulation automatique sur erreur
final txResult2 = await db.transaction(() async {
  await db.insert('users', {
    'username': 'jane',
    'email': 'jane@example.com',
  });
  throw Exception('Erreur mÃ©tier'); // DÃ©clenche l'annulation
}, rollbackOnError: true);
```

## Configuration de la sÃ©curitÃ©

**MÃ©canismes de sÃ©curitÃ© des donnÃ©es** :
- La double protection garantit que les donnÃ©es ne sont jamais perdues.
- RÃ©cupÃ©ration automatique aprÃ¨s plantage.
- Persistance sÃ©curisÃ©e dÃ¨s que l'opÃ©ration rÃ©ussit.
- Cryptage haute rÃ©sistance pour les donnÃ©es sensibles.

> [!WARNING]
> **Gestion des clÃ©s** : Changer la `encryptionKey` rendra les anciennes donnÃ©es illisibles (sauf migration). Ne codez pas les clÃ©s en dur ; rÃ©cupÃ©rez-les depuis un serveur sÃ©curisÃ©.

```dart
final db = await ToStore.open(
  config: DataStoreConfig(
    encryptionConfig: EncryptionConfig(
      // Algorithmes supportÃ©s : none, xorObfuscation, chacha20Poly1305, aes256Gcm
      encryptionType: EncryptionType.chacha20Poly1305, 
      
      // ClÃ© d'encodage (obligatoire Ã  l'initialisation)
      encodingKey: 'Votre-ClÃ©-D-Encodage-De-32-Octets...', 
      
      // ClÃ© de cryptage pour les donnÃ©es critiques
      encryptionKey: 'Votre-ClÃ©-De-Cryptage-SÃ©curisÃ©e...',
      
      // Liaison Ã  l'appareil (basÃ© sur le chemin)
      // Si activÃ©, les clÃ©s sont liÃ©es au chemin et aux caractÃ©ristiques de l'appareil.
      // Renforce la sÃ©curitÃ© contre le vol de fichiers de base de donnÃ©es.
      deviceBinding: false, 
    ),
    // WAL (Write-Ahead Logging) activÃ© par dÃ©faut
    enableJournal: true, 
    // Force l'Ã©criture disque au commit (mettre Ã  false pour plus de performance)
    persistRecoveryOnCommit: true,
  ),
);
```


## Performance et ExpÃ©rience

### SpÃ©cifications de performance

- **Vitesse de dÃ©marrage** : DÃ©marrage et affichage instantanÃ©s mÃªme avec plus de 10 millions d'enregistrements sur un smartphone moyen.
- **RequÃªtes** : IndÃ©pendant de l'Ã©chelle, recherche ultra-rapide constante Ã  tout volume de donnÃ©es.
- **SÃ©curitÃ© des donnÃ©es** : Garanties de transaction ACID + rÃ©cupÃ©ration aprÃ¨s crash pour zÃ©ro perte de donnÃ©es.

### Recommandations

- ðŸ“± **Projet d'exemple** : Un exemple complet d'application Flutter est disponible dans le rÃ©pertoire `example`.
- ðŸš€ **Production** : Utilisez le mode Release pour des performances bien supÃ©rieures au mode Debug.
- âœ… **Tests standards** : Toutes les fonctionnalitÃ©s clÃ©s ont passÃ© les tests d'intÃ©gration.




Si Tostore vous aide, n'hÃ©sitez pas Ã  nous donner une â­ï¸




## Roadmap

Tostore dÃ©veloppe activement de nouvelles fonctionnalitÃ©s pour renforcer l'infrastructure de donnÃ©es Ã  l'Ã¨re de l'IA :

- **Vecteurs haute dimension** : Ajout de la recherche vectorielle et d'algorithmes de recherche sÃ©mantique.
- **DonnÃ©es multi-modales** : Traitement de bout en bout, des donnÃ©es brutes aux vecteurs de caractÃ©ristiques.
- **Structures de donnÃ©es en graphe** : Support pour le stockage et la requÃªte efficace de graphes de connaissances.





> **Recommandation** : Les dÃ©veloppeurs mobiles peuvent aussi considÃ©rer le [Framework Toway](https://github.com/tocreator/toway), une solution full-stack qui automatise les requÃªtes, le chargement, le stockage, le cache et l'affichage des donnÃ©es.




## Plus de ressources

- ðŸ“– **Documentation** : [Wiki](https://github.com/tocreator/tostore)
- ðŸ“¢ **Feedback** : [GitHub Issues](https://github.com/tocreator/tostore/issues)
- ðŸ’¬ **Discussion** : [GitHub Discussions](https://github.com/tocreator/tostore/discussions)


## Licence

Ce projet est sous licence MIT - voir le fichier [LICENSE](LICENSE) pour plus de dÃ©tails.

---
