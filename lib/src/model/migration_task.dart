import 'table_schema.dart';

/// migration task, for storing table structure, table data migration operations
class MigrationTask {
  // task id
  final String taskId;
  // table name
  final String tableName;
  // whether the table structure is updated
  final bool isSchemaUpdated;
  // pending migration spaces
  final List<String> pendingMigrationSpaces;
  // migration operations
  final List<MigrationOperation> operations;
  // create time
  final DateTime createTime;
  // directory index
  final int dirIndex;
  // whether the migration task is auto generated
  final bool isAutoGenerated;

  const MigrationTask({
    required this.taskId,
    required this.tableName,
    required this.isSchemaUpdated,
    required this.pendingMigrationSpaces,
    required this.operations,
    required this.createTime,
    required this.dirIndex,
    this.isAutoGenerated = false,
  });

  /// create from json
  factory MigrationTask.fromJson(Map<String, dynamic> json) => MigrationTask(
        taskId: json['taskId'] as String,
        tableName: json['tableName'] as String,
        isSchemaUpdated: json['isSchemaUpdated'] as bool,
        pendingMigrationSpaces:
            (json['pendingMigrationSpaces'] as List).cast<String>(),
        operations: (json['operations'] as List)
            .map((e) => MigrationOperation.fromJson(e as Map<String, dynamic>))
            .toList(),
        createTime: DateTime.parse(json['createTime'] as String),
        dirIndex: json['dirIndex'] as int,
        isAutoGenerated: json['isAutoGenerated'] as bool? ?? true,
      );

  /// convert to json
  Map<String, dynamic> toJson() => {
        'taskId': taskId,
        'tableName': tableName,
        'isSchemaUpdated': isSchemaUpdated,
        'pendingMigrationSpaces': pendingMigrationSpaces,
        'operations': operations.map((op) => op.toJson()).toList(),
        'createTime': createTime.toIso8601String(),
        'dirIndex': dirIndex,
        'isAutoGenerated': isAutoGenerated,
      };

  /// set the table structure change status
  MigrationTask setSchemaUpdated(bool updated) => copyWith(
        isSchemaUpdated: updated,
      );

  /// update the pending migration spaces
  MigrationTask updatePendingSpaces(List<String> spaces) => copyWith(
        pendingMigrationSpaces: spaces,
      );

  /// add a single pending migration space
  MigrationTask addPendingSpace(String space) {
    if (pendingMigrationSpaces.contains(space)) {
      return this;
    }
    return copyWith(
      pendingMigrationSpaces: [...pendingMigrationSpaces, space],
    );
  }

  /// remove a single pending migration space
  MigrationTask removePendingSpace(String space) {
    if (!pendingMigrationSpaces.contains(space)) {
      return this;
    }
    return copyWith(
      pendingMigrationSpaces: [
        for (final s in pendingMigrationSpaces)
          if (s != space) s
      ],
    );
  }

  /// create a copy (basic method)
  MigrationTask copyWith({
    String? taskId,
    String? tableName,
    bool? isSchemaUpdated,
    List<String>? pendingMigrationSpaces,
    List<MigrationOperation>? operations,
    DateTime? createTime,
    int? dirIndex,
    bool? isAutoGenerated,
  }) =>
      MigrationTask(
        taskId: taskId ?? this.taskId,
        tableName: tableName ?? this.tableName,
        isSchemaUpdated: isSchemaUpdated ?? this.isSchemaUpdated,
        pendingMigrationSpaces:
            pendingMigrationSpaces ?? this.pendingMigrationSpaces,
        operations: operations ?? this.operations,
        createTime: createTime ?? this.createTime,
        dirIndex: dirIndex ?? this.dirIndex,
        isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      );
}

/// Migration operation type
enum MigrationType {
  addField,
  removeField,
  renameField,
  modifyField,
  addIndex,
  removeIndex,
  modifyIndex,
  renameTable,
  setPrimaryKeyConfig,
  dropTable,
  addForeignKey,
  removeForeignKey,
  modifyForeignKey,
}

/// model for field update, allow explicit distinction of whether a value is set
class FieldSchemaUpdate {
  final String name;
  final DataType? type;
  final bool? nullable;
  final dynamic defaultValue;
  final bool? unique;
  final String? comment;
  final int? minLength;
  final int? maxLength;
  final num? minValue;
  final num? maxValue;
  final DefaultValueType? defaultValueType;
  final String? fieldId;
  final VectorFieldConfig? vectorConfig;

  // track which properties are explicitly set
  final Map<String, bool> _explicitlySet;

  FieldSchemaUpdate({
    required this.name,
    this.type,
    this.nullable,
    this.defaultValue,
    this.unique,
    this.comment,
    this.minLength,
    this.maxLength,
    this.minValue,
    this.maxValue,
    this.defaultValueType,
    this.fieldId,
    this.vectorConfig,
  }) : _explicitlySet = {
          'type': type != null,
          'nullable': nullable != null,
          'defaultValue':
              true, // defaultValue always considered explicitly set, even if null
          'unique': unique != null,
          'comment':
              true, // comment always considered explicitly set, even if null
          'minLength':
              true, // minLength always considered explicitly set, even if null
          'maxLength':
              true, // maxLength always considered explicitly set, even if null
          'minValue':
              true, // minValue always considered explicitly set, even if null
          'maxValue':
              true, // maxValue always considered explicitly set, even if null
          'defaultValueType': defaultValueType != null,
          'fieldId': fieldId != null,
          'vectorConfig': vectorConfig != null,
        };

  /// check if the property is explicitly set
  bool isExplicitlySet(String propertyName) {
    return _explicitlySet[propertyName] ?? false;
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'type': type?.name,
      'nullable': nullable,
      'defaultValue': defaultValue,
      'unique': unique,
      'comment': comment,
      'minLength': minLength,
      'maxLength': maxLength,
      'minValue': minValue,
      'maxValue': maxValue,
      if (defaultValueType != null)
        'defaultValueType': defaultValueType.toString().split('.').last,
      'fieldId': fieldId,
      if (vectorConfig != null) 'vectorConfig': vectorConfig!.toJson(),
      '_explicitlySet': _explicitlySet,
    };
  }

  factory FieldSchemaUpdate.fromJson(Map<String, dynamic> json) {
    // Parse default value type
    DefaultValueType? getDefaultValueType() {
      final typeStr = json['defaultValueType'] as String?;
      if (typeStr == null) return null;

      switch (typeStr.toLowerCase()) {
        case 'currenttimestamp':
          return DefaultValueType.currentTimestamp;
        default:
          return DefaultValueType.none;
      }
    }

    final result = FieldSchemaUpdate(
      name: json['name'],
      type: json['type'] != null
          ? DataType.values.firstWhere((e) => e.name == json['type'])
          : null,
      nullable: json['nullable'],
      defaultValue: json['defaultValue'],
      unique: json['unique'],
      comment: json['comment'],
      minLength: json['minLength'],
      maxLength: json['maxLength'],
      minValue: json['minValue'],
      maxValue: json['maxValue'],
      defaultValueType: getDefaultValueType(),
      fieldId: json['fieldId'],
      vectorConfig: json['vectorConfig'] != null
          ? VectorFieldConfig.fromJson(
              json['vectorConfig'] as Map<String, dynamic>)
          : null,
    );

    // if JSON contains _explicitlySet, use it to update _explicitlySet
    if (json['_explicitlySet'] is Map) {
      result._explicitlySet
          .addAll(Map<String, bool>.from(json['_explicitlySet'] as Map));
    }

    return result;
  }
}

/// migration operation
class MigrationOperation {
  final MigrationType type;
  final FieldSchema? field;
  final FieldSchemaUpdate? fieldUpdate;
  final String? fieldName;
  final String? newName;
  final IndexSchema? index;
  final String? indexName;
  final List<String>? fields;
  final bool? unique;
  final String? newTableName;
  final PrimaryKeyConfig? primaryKeyConfig;
  final PrimaryKeyConfig? oldPrimaryKeyConfig;
  final ForeignKeySchema? foreignKey;
  final String? foreignKeyName;
  final ForeignKeySchema? oldForeignKey;

  const MigrationOperation({
    required this.type,
    this.field,
    this.fieldUpdate,
    this.fieldName,
    this.newName,
    this.index,
    this.indexName,
    this.fields,
    this.unique,
    this.newTableName,
    this.primaryKeyConfig,
    this.oldPrimaryKeyConfig,
    this.foreignKey,
    this.foreignKeyName,
    this.oldForeignKey,
  });

  Map<String, dynamic> toJson() {
    return {
      'type': type.name,
      'field': field?.toJson(),
      'fieldUpdate': fieldUpdate?.toJson(),
      'fieldName': fieldName,
      'newName': newName,
      'index': index?.toJson(),
      'indexName': indexName,
      'fields': fields,
      'unique': unique,
      'newTableName': newTableName,
      'primaryKeyConfig': primaryKeyConfig?.toJson(),
      'oldPrimaryKeyConfig': oldPrimaryKeyConfig?.toJson(),
      'foreignKey': foreignKey?.toJson(),
      'foreignKeyName': foreignKeyName,
      'oldForeignKey': oldForeignKey?.toJson(),
    };
  }

  factory MigrationOperation.fromJson(Map<String, dynamic> json) {
    return MigrationOperation(
      type: MigrationType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => MigrationType.addField,
      ),
      field: json['field'] != null ? FieldSchema.fromJson(json['field']) : null,
      fieldUpdate: json['fieldUpdate'] != null
          ? FieldSchemaUpdate.fromJson(json['fieldUpdate'])
          : null,
      fieldName: json['fieldName'],
      newName: json['newName'],
      index: json['index'] != null ? IndexSchema.fromJson(json['index']) : null,
      indexName: json['indexName'],
      fields: (json['fields'] as List?)?.cast<String>(),
      unique: json['unique'],
      newTableName: json['newTableName'],
      primaryKeyConfig: json['primaryKeyConfig'] != null
          ? PrimaryKeyConfig.fromJson(json['primaryKeyConfig'])
          : null,
      oldPrimaryKeyConfig: json['oldPrimaryKeyConfig'] != null
          ? PrimaryKeyConfig.fromJson(json['oldPrimaryKeyConfig'])
          : null,
      foreignKey: json['foreignKey'] != null
          ? ForeignKeySchema.fromJson(json['foreignKey'])
          : null,
      foreignKeyName: json['foreignKeyName'],
      oldForeignKey: json['oldForeignKey'] != null
          ? ForeignKeySchema.fromJson(json['oldForeignKey'])
          : null,
    );
  }
}

/// migration task status
class MigrationStatus {
  /// task id
  final String taskId;

  /// whether the task is completed
  final bool isCompleted;

  /// task create time
  final DateTime createTime;

  /// pending spaces
  final List<String> pendingSpaces;

  /// processed spaces count
  final int processedSpacesCount;

  /// total spaces count
  final int totalSpacesCount;

  /// progress percentage (0-100)
  double get progressPercentage => totalSpacesCount > 0
      ? (processedSpacesCount / totalSpacesCount * 100)
      : 100.0;

  const MigrationStatus({
    required this.taskId,
    required this.isCompleted,
    required this.createTime,
    required this.pendingSpaces,
    required this.processedSpacesCount,
    required this.totalSpacesCount,
  });

  @override
  String toString() {
    return 'MigrationStatus{taskId: $taskId, isCompleted: $isCompleted, '
        'progress: ${progressPercentage.toStringAsFixed(1)}%, '
        'pendingSpaces: ${pendingSpaces.length}}';
  }
}
